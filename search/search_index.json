{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyCircuitKit","text":"## PyCircuitKit  PyCircuitKit is a modern Python toolkit for building circuits, generating SPICE netlists, and running analyses (Monte Carlo, AC, transient) with lightweight testing helpers.  **Features**  - Clean, typed APIs - Pluggable SPICE runners (ngspice) - Example-driven tutorials and automated tests  ### Quick start   <pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install -e .\n</code></pre>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Installation: installation.md</li> <li>Getting started: getting-started.md</li> <li>Examples: examples.md</li> <li>Examples Gallery: examples-gallery.md</li> </ul>"},{"location":"ac-stability/","title":"AC Stability (Bode, PM/GM)","text":"<p>Compute Bode magnitude/phase and stability margins from an AC run.</p> <p></p> <p>Note: NGSpice names nodes as <code>n1</code>, <code>n2</code>, ... in the RAW file by default. Use <code>v(n1)</code> for the first node voltage (output in the RC examples).</p>"},{"location":"ac-stability/#quick-bode","title":"Quick Bode","text":"<pre><code>from cat.analysis import bode\n\n# Run an AC sweep and get (f, mag_db, phase_deg)\nf, mag_db, ph = bode(c, y_out=\"v(n1)\", sweep_type=\"dec\", n=201, fstart=10.0, fstop=1e6)\n</code></pre> <p>The circuit must include a small-signal AC source (e.g., <code>VA()</code> or <code>Iac</code>).</p>"},{"location":"ac-stability/#margins-and-bandwidth","title":"Margins and bandwidth","text":"<pre><code>from cat.analysis import ac_gain_phase, bandwidth_3db, crossover_freq_0db, phase_margin, gain_margin_db\n\nres = run_ac(c, \"dec\", 201, 10.0, 1e6)\nf, g_db, ph = ac_gain_phase(res.traces, y_out=\"v(n1)\")\n\nbw = bandwidth_3db(res.traces, y_out=\"v(n1)\")\nwc = crossover_freq_0db(res.traces, y_out=\"v(n1)\")\npm = phase_margin(res.traces, y_out=\"v(n1)\")\ngm = gain_margin_db(res.traces, y_out=\"v(n1)\")\nprint(bw, wc, pm, gm)\n</code></pre> <p>Use <code>plot_bode(ts, y)</code> to plot the complex trace when available.</p>"},{"location":"concepts/","title":"Core Concepts","text":"<ul> <li>Ports: typed terminals on components (positive/negative/node).</li> <li>Nets: logical nodes (use <code>GND</code> for ground). A <code>Net</code> can be named for readability.</li> <li>Components: objects with <code>ports</code> and a <code>spice_card(net_of)</code> method.</li> <li>Circuit: container that owns components, connections, and optional SPICE directives.</li> </ul>"},{"location":"concepts/#wiring-rules","title":"Wiring rules","text":"<ul> <li>Connect <code>Port</code> to <code>Net</code>, or <code>Port</code> to <code>Port</code> (auto-creates a shared Net).</li> <li>All ports must be connected before building the netlist.</li> <li><code>GND</code> is reserved (node \"0\").</li> </ul>"},{"location":"concepts/#minimal-rc-example","title":"Minimal RC example","text":"<pre><code>from cat.core.circuit import Circuit\nfrom cat.core.components import Vdc, Resistor, Capacitor\nfrom cat.core.net import GND\n\nc = Circuit(\"rc\")\nV1, R1, C1 = Vdc(\"1\", 5.0), Resistor(\"1\", \"1k\"), Capacitor(\"1\", \"100n\")\nc.add(V1, R1, C1)\nc.connect(V1.ports[0], R1.ports[0])  # vin\nc.connect(R1.ports[1], C1.ports[0])  # vout\nc.connect(V1.ports[1], GND)\nc.connect(C1.ports[1], GND)\n\nprint(c.build_netlist())\n</code></pre>"},{"location":"concepts/#directives","title":"Directives","text":"<p>Use <code>circuit.add_directive(\".model ...\")</code> or <code>.param</code>, <code>.include</code>, etc., to embed raw SPICE lines.</p>"},{"location":"cookbook/","title":"Cookbook","text":"<p>Short, copy-paste recipes for common tasks.</p>"},{"location":"cookbook/#3-db-bandwidth","title":"\u22123 dB bandwidth","text":"<pre><code>from cat.analysis import bandwidth_3db\nbw = bandwidth_3db(res.traces, y_out=\"v(n1)\")\n</code></pre>"},{"location":"cookbook/#0-db-crossover-and-margins","title":"0 dB crossover and margins","text":"<pre><code>from cat.analysis import crossover_freq_0db, phase_margin, gain_margin_db\nwc = crossover_freq_0db(res.traces, y_out=\"v(n1)\")\npm = phase_margin(res.traces, y_out=\"v(n1)\")\ngm = gain_margin_db(res.traces, y_out=\"v(n1)\")\n</code></pre>"},{"location":"cookbook/#overshoot-and-settling-time","title":"Overshoot and settling time","text":"<pre><code>from cat.analysis import overshoot_pct, settling_time\nov = overshoot_pct(res.traces, \"v(n1)\")  # %\nst = settling_time(res.traces, \"v(n1)\")\n</code></pre>"},{"location":"cookbook/#interpolate-at-a-given-time-per-run","title":"Interpolate at a given time (per run)","text":"<pre><code>import numpy as np\n\ndef sample_at(ts, name: str, t: float) -&gt; float:\n    t_arr = ts[\"time\"].values\n    y_arr = ts[name].values\n    return float(np.interp(t, t_arr, y_arr))\n</code></pre>"},{"location":"cookbook/#stack-multiple-runs-into-a-dataframe","title":"Stack multiple runs into a DataFrame","text":"<pre><code>from cat.analysis import stack_runs_to_df\n# runs: list[AnalysisResult]\ndf = stack_runs_to_df(runs, y=[\"v(n1)\"], with_x=True)\n</code></pre>"},{"location":"examples-gallery/","title":"Examples Gallery","text":"<p>Curated outputs from runnable examples. Click images or links to explore.</p>"},{"location":"examples-gallery/#rc-bode-ac","title":"RC Bode (AC)","text":"<ul> <li>Guide: AC Stability</li> <li>Script: <code>examples/ac_bode.py</code></li> </ul>"},{"location":"examples-gallery/#op-amp-closed-loop-bode","title":"Op-Amp Closed-Loop Bode","text":"<ul> <li>Guide: Op-Amp Stability</li> <li>Script: <code>examples/opamp_stability.py</code></li> </ul>"},{"location":"examples-gallery/#step-grid-rc-step-vs-r","title":"STEP Grid (RC step vs R)","text":"<ul> <li>Guide: Sweeps and .STEP</li> <li>Script: <code>examples/step_sweep_fig.py</code></li> </ul>"},{"location":"examples-gallery/#monte-carlo-histogram","title":"Monte Carlo (histogram)","text":"<ul> <li>Guide: Monte Carlo</li> <li>Script: <code>examples/monte_carlo_fig.py</code></li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This project ships runnable examples in <code>examples/</code>:</p> <ul> <li><code>rc_tran.py</code> \u2014 transient of an RC low-pass</li> <li><code>ac_bode.py</code> \u2014 RC Bode magnitude/phase plot</li> <li><code>dc_sweep.py</code> \u2014 DC sweep example</li> <li><code>step_sweep_grid.py</code> \u2014 Python grid over parameters + DataFrame</li> <li><code>monte_carlo_rc.py</code> \u2014 Monte Carlo with metrics and plots</li> <li><code>opamp_closed_loop.py</code> \u2014 simple op-amp closed-loop wiring</li> <li><code>opamp_stability.py</code> \u2014 op-amp closed-loop Bode and margins</li> <li><code>pt1000_mc.py</code> \u2014 PT1000 front-end Monte Carlo (temp error histogram)</li> <li><code>rc_highpass.py</code> \u2014 RC highpass netlist builder</li> <li><code>import_ltspice_and_run.py</code> \u2014 import LTspice netlist and run</li> </ul> <p>Run them as modules:</p> <pre><code>python -m examples.rc_tran\npython -m examples.ac_bode\npython -m examples.step_sweep_grid\npython -m examples.monte_carlo_rc\n</code></pre> <p>See the <code>examples/</code> folder for details and more scripts.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>Create a Circuit and build a netlist:</p> <pre><code>from cat.core.circuit import Circuit\nfrom cat.core.components import Vdc, Resistor, Capacitor\nfrom cat.core.net import GND\n\nc = Circuit(\"rc_lowpass\")\nV1 = Vdc(\"1\", 5.0)\nR1 = Resistor(\"1\", \"1k\")\nC1 = Capacitor(\"1\", \"100n\")\n\nc.add(V1, R1, C1)\nc.connect(V1.ports[0], R1.ports[0])\nc.connect(R1.ports[1], C1.ports[0])\nc.connect(V1.ports[1], GND)\nc.connect(C1.ports[1], GND)\n\nprint(c.build_netlist())\n</code></pre> <p>This will print a SPICE netlist ready to be executed by a SPICE runner.</p>"},{"location":"getting-started/#run-a-transient-in-one-line","title":"Run a transient in one line","text":"<p>You can run a transient (.TRAN) analysis and get a pandas DataFrame directly:</p> <pre><code>from cat.analysis import run_tran\n\ndf = run_tran(c, \"10us\", \"5ms\", return_df=True)\nprint(df.head())\n</code></pre> <p>Or keep the full result object for advanced usage:</p> <pre><code>res = run_tran(c, \"10us\", \"5ms\")\nprint(res.traces.names)\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Install PyCircuitKit in a virtual environment:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install -e .\n</code></pre> <p>Recommended dev tools:</p> <ul> <li>pytest</li> <li>mypy</li> <li>ruff</li> </ul> <p>Optional (for docs):</p> <ul> <li>mkdocs-material</li> <li>mkdocstrings</li> </ul>"},{"location":"ltspice-import/","title":"Importing LTspice Netlists","text":"<p>CAT can import SPICE netlists exported from LTspice (View \u2192 SPICE Netlist) and run analyses using the same Python API.</p>"},{"location":"ltspice-import/#supported-features","title":"Supported features","text":"<ul> <li><code>.include</code> and <code>.param</code> (expanded recursively)</li> <li>Devices: R, C, L, V/I (DC/AC), <code>PULSE</code>, <code>SIN</code>, <code>PWL</code></li> <li>Controlled sources: E/G/F/H</li> <li>Diode <code>D</code></li> <li>Switches: <code>S</code> (VSWITCH), <code>W</code> (ISWITCH)</li> <li>Simple <code>.SUBCKT</code> flattening (one level, params via <code>{NAME}</code> placeholders)</li> </ul>"},{"location":"ltspice-import/#quick-example","title":"Quick example","text":"<pre><code>from cat.io.ltspice_parser import from_ltspice_file\nfrom cat.analysis import run_tran\n\nc = from_ltspice_file(\"./my_filter.cir\")  # exported plain netlist\nres_df = run_tran(c, \"1us\", \"2ms\", return_df=True)\nprint(res_df.head())\n</code></pre>"},{"location":"ltspice-import/#notes","title":"Notes","text":"<ul> <li><code>.asc</code> schematic files are not netlists \u2014 export the SPICE netlist first.</li> <li>For switches, add your <code>.model</code> directives via <code>circuit.add_directive(\".model ...\")</code>   if the model is not already present in the netlist.</li> <li>SUBCKT flattening: the importer expands a single level of subcircuit instances.   Parameters are substituted when referenced as <code>{PARAM}</code> in the subckt body.</li> <li>If you see errors around unknown cards, file an issue with a minimal netlist.</li> </ul>"},{"location":"monte-carlo/","title":"Monte Carlo","text":"<p>Run Monte Carlo by mapping components to distributions and a per-trial analysis:</p> <p></p> <pre><code>from cat.core.circuit import Circuit\nfrom cat.core.components import Vdc, Resistor, Capacitor\nfrom cat.core.net import GND\nfrom cat.analysis import OP, monte_carlo, NormalPct\n\nc = Circuit(\"rc\")\nV1, R1, C1 = Vdc(\"1\", 5.0), Resistor(\"1\", \"1k\"), Capacitor(\"1\", \"100n\")\nc.add(V1, R1, C1)\nc.connect(V1.ports[0], R1.ports[0])\nc.connect(R1.ports[1], C1.ports[0])\nc.connect(V1.ports[1], GND)\nc.connect(C1.ports[1], GND)\n\nmc = monte_carlo(\n    circuit=c,\n    mapping={R1: NormalPct(0.05)},\n    n=16,\n    analysis_factory=lambda: OP(),\n    seed=123,\n)\n\ndf = mc.to_dataframe(param_prefix=\"param_\")\nprint(df.head())\n</code></pre> <p>Tips: - Use <code>workers</code> for parallel execution: <code>monte_carlo(..., workers=4)</code>. - Provide a metric function to compute scalar KPIs per trial, or set <code>y=[...]</code> and <code>sample_at</code> to extract trace values.</p>"},{"location":"monte-carlo/#progress-bar-callback","title":"Progress bar / callback","text":"<p>Add a lightweight progress bar to stderr:</p> <pre><code>mc = monte_carlo(\n    circuit=c,\n    mapping={R1: NormalPct(0.01)},\n    n=1000,\n    analysis_factory=lambda: OP(),\n    progress=True,   # prints: \"MC: 317/1000 (31%)\"\n)\n</code></pre> <p>Or provide your own callback (<code>done</code>, <code>total</code>):</p> <pre><code>def cb(done: int, total: int) -&gt; None:\n    print(f\"{done}/{total}\", end=\"\\r\")\n\nmc = monte_carlo(c, mapping={R1: NormalPct(0.01)}, n=1000,\n                 analysis_factory=lambda: OP(), progress=cb)\n</code></pre>"},{"location":"opamp-stability/","title":"Op-Amp Stability","text":"<p>Analyze closed-loop Bode and margins using the ideal op-amp helper.</p> <p></p>"},{"location":"opamp-stability/#inverting-topology-with-ideal-oa","title":"Inverting topology with ideal OA","text":"<pre><code>from cat import Circuit, GND, opamp_inverting\nfrom cat.core.components import VA, R\nfrom cat.core.net import Net\nfrom cat.analysis import AC, ac_gain_phase, phase_margin, gain_margin_db\n\nc = Circuit(\"opamp_inv\")\n\n# Small-signal input (1 V)\nvin = VA(ac_mag=1.0); c.add(vin)\n\n# Output/load node\nvout = Net(\"vout\"); load = R(\"10k\"); c.add(load)\nc.connect(load.ports[0], vout); c.connect(load.ports[1], GND)\n\n# Inverting amplifier: gain = -Rf/Rin = -100k/10k = -10\nopamp_inverting(c, inp=vin.ports[0], out=vout, ref=GND, Rin=\"10k\", Rf=\"100k\", gain=1e6)\nc.connect(vin.ports[1], GND)\n\nres = AC(\"dec\", 201, 10.0, 1e6).run(c)\nf, mag_db, ph = ac_gain_phase(res.traces, \"v(n1)\")\npm = phase_margin(res.traces, \"v(n1)\")\ngm = gain_margin_db(res.traces, \"v(n1)\")\nprint(pm, gm)\n</code></pre> <p>Notes: - The ideal OA is modeled as a high-gain VCVS; no power rails needed. - Use <code>plot_bode(ts, y)</code> to visualize complex AC traces. - <code>phase_margin</code> falls back to estimate if phase is missing; provide complex or phase info when possible.</p> <p>See also the runnable script under <code>examples/opamp_stability.py</code>.</p>"},{"location":"plots/","title":"Plotting","text":"<p>CAT includes light plotting helpers that use Matplotlib when available.</p>"},{"location":"plots/#plot-traces","title":"Plot traces","text":"<pre><code>from cat.analysis.viz.plot import plot_traces\nfig = plot_traces(res.traces, ys=[\"v(n1)\"], title=\"Vout vs time\")\n</code></pre>"},{"location":"plots/#bode-plot","title":"Bode plot","text":"<pre><code>from cat.analysis.viz.plot import plot_bode\n# y must be a complex trace (e.g., AC result)\nfig_mag, fig_phase = plot_bode(res.traces, y=\"v(n1)\")\n</code></pre>"},{"location":"plots/#plot-sweeps-stacked-dataframe","title":"Plot sweeps (stacked DataFrame)","text":"<pre><code>from cat.analysis.viz.plot import plot_sweep_df\nfig = plot_sweep_df(df, x=\"time\", y=\"v(n1)\", hue=\"R\", title=\"Sweep R\")\n</code></pre> <p>If Matplotlib is not installed, these helpers raise a clear error.</p>"},{"location":"preview/","title":"Circuit Preview (Summary and Graphviz)","text":"<p>Use the new preview helpers to validate connectivity and generate a quick schematic-like view.</p>"},{"location":"preview/#connectivity-summary","title":"Connectivity summary","text":"<pre><code>print(c.summary())\n</code></pre> <p>Outputs a compact mapping of <code>ref.port -&gt; net</code>, highlights nets with degree 1 and unconnected ports.</p>"},{"location":"preview/#graphviz-rendering","title":"Graphviz rendering","text":"<pre><code>dot = c.to_dot()\nok = c.render_svg(\"circuit_preview.svg\")  # requires 'dot' in PATH\n</code></pre> <p>If Graphviz isn't installed, you still get a <code>.dot</code> file:</p> <pre><code>dot -Tsvg circuit_preview.dot -o preview.svg\n</code></pre> <p>Example (RC low-pass):</p> <p></p>"},{"location":"sweeps-step/","title":"Sweeps and .STEP","text":"<p>There are two ways to sweep parameters:</p> <ul> <li>Python-side sweeps (<code>step_param</code>, <code>step_grid</code>) \u2014 easiest to combine with Pandas.</li> <li>Native SPICE <code>.step</code> directives \u2014 use <code>run_step_native</code> to parse multi-plot RAW.</li> </ul> <p></p>"},{"location":"sweeps-step/#python-sweeps","title":"Python sweeps","text":"<p>Single parameter:</p> <pre><code>from cat.analysis import step_param, TRAN\nres = step_param(\n    c,\n    name=\"R\",\n    values=[\"1k\",\"2k\",\"5k\"],\n    analysis_factory=lambda: TRAN(\"50us\",\"5ms\"),\n    progress=True,   # prints progress to stderr\n)\n</code></pre> <p>Grid of parameters:</p> <pre><code>from cat.analysis import ParamGrid, step_grid\ngrid: ParamGrid = {\"R\": [\"1k\",\"2k\"], \"C\": [\"100n\",\"220n\"]}\nstep = step_grid(c, grid, analysis_factory=lambda: TRAN(\"50us\",\"5ms\"), progress=True)\n</code></pre> <p>Stacking to DataFrame:</p> <pre><code>from cat.analysis import stack_step_to_df\ndf = stack_step_to_df(step, y=[\"v(n1)\"], with_x=True)\n</code></pre> <p>Plotting grouped curves (optional):</p> <pre><code>from cat.analysis.viz.plot import plot_sweep_df\nfig = plot_sweep_df(df, x=\"time\", y=\"v(n1)\", hue=\"R\")\n\n### Custom progress callback\n\nYou can pass a function `callback(done, total)` to receive updates instead of the default bar:\n\n```python\ndef cb(done: int, total: int) -&gt; None:\n    print(f\"{done}/{total}\", end=\"\\r\")\n\nstep = step_grid(c, grid, analysis_factory=lambda: TRAN(\"50us\",\"5ms\"), progress=cb)\n</code></pre> <pre><code>\n## Native .STEP\n\nProvide directives that include `.step` and parse all plots:\n```python\nfrom cat.analysis import run_step_native\nout = run_step_native(c, directives=[\".step param R list 1k 2k 5k\", \".tran 50us 5ms\"])\nsets = out.tracesets  # list[TraceSet]\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<ul> <li>ngspice not found: install it and ensure it's on PATH.</li> <li>macOS: <code>brew install ngspice</code></li> <li>Ubuntu: <code>sudo apt install -y ngspice</code></li> <li>Windows: install Spice64 and add the <code>bin</code> to PATH</li> <li>Binary RAW: <code>Binary RAW not supported yet</code> \u2192 we force ASCII in our runner, but if you   run NGSpice manually, set <code>set filetype=ascii</code> in a <code>.control</code> block or use <code>-r</code>.</li> <li>Unconnected port: connect every component port to a Net or another Port before building.</li> <li>Missing .model for switches: add directives with <code>circuit.add_directive(\".model ...\")</code>.</li> <li>AC analysis looks flat or phase missing: ensure you use small-signal sources (VA/Iac),   or reconstruct complex traces with <code>ac_gain_phase</code> which handles re/im or mag/phase.</li> </ul>"},{"location":"reference/analysis/","title":"Analysis API","text":"<p>Placeholder for analysis API docs.</p>"},{"location":"reference/analysis/#cat.analysis.Bode","title":"<code>Bode</code>  <code>dataclass</code>","text":"<p>Container opcional para quem preferir um objeto tipado.</p> Source code in <code>src/cat/analysis/metrics_ac.py</code> <pre><code>@dataclass(frozen=True)\nclass Bode:\n    \"\"\"Container opcional para quem preferir um objeto tipado.\"\"\"\n\n    f: NDArray[Any]  # Hz\n    mag_db: NDArray[Any]  # dB\n    ph_deg: NDArray[Any]  # graus\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.MonteCarloResult","title":"<code>MonteCarloResult</code>  <code>dataclass</code>","text":"Source code in <code>src/cat/analysis/montecarlo.py</code> <pre><code>@dataclass(frozen=True)\nclass MonteCarloResult:\n    samples: list[dict[str, float]]\n    runs: list[AnalysisResult]\n\n    def to_dataframe(\n        self,\n        metric: (\n            Callable[[AnalysisResult], float | dict[str, Any]]\n            | TMapping[str, Callable[[AnalysisResult], Any]]\n            | None\n        ) = None,\n        *,\n        trial_name: str = \"trial\",\n        param_prefix: str = \"\",\n        y: Sequence[str] | None = None,\n        sample_at: float | None = None,\n    ) -&gt; Any:\n        \"\"\"\n        Returns a per-trial DataFrame with columns:\n          - trial (index within this Monte Carlo run)\n          - one column per sampled parameter (from `samples`), optionally prefixed\n          - optional metric columns computed from each AnalysisResult\n          - optional raw trace columns (final value or sampled at `sample_at` seconds)\n\n        metric:\n          - callable \u2192 result stored in column 'metric' (float or scalar)\n          - mapping name-&gt;callable \u2192 adds one column per metric name\n        y: list of trace names to extract values for each run. If `sample_at` is given,\n           the value is linearly interpolated at t=sample_at using the run's time axis;\n           otherwise, the last value in the trace is used.\n        \"\"\"\n        try:\n            pd: Any = importlib.import_module(\"pandas\")\n        except Exception as exc:  # pragma: no cover\n            raise RuntimeError(\"pandas is required for MonteCarloResult.to_dataframe()\") from exc\n\n        rows: list[dict[str, Any]] = []\n        for i, (s, run) in enumerate(zip(self.samples, self.runs, strict=False)):\n            # copy sampled params; optionally add prefix\n            if param_prefix:\n                row = {f\"{param_prefix}{k}\": v for k, v in s.items()}\n            else:\n                row = dict(s)\n            row[trial_name] = i\n            if metric is not None:\n                if hasattr(metric, \"items\"):\n                    for name, fn in cast(\n                        TMapping[str, Callable[[AnalysisResult], Any]], metric\n                    ).items():\n                        row[name] = fn(run)\n                else:\n                    m = cast(Callable[[AnalysisResult], Any], metric)(run)\n                    if isinstance(m, dict):\n                        row.update(m)\n                    else:\n                        row[\"metric\"] = m\n\n            if y:\n                try:\n                    import numpy as _np  # local import to avoid hard dep at module import\n                except Exception:  # pragma: no cover\n                    _np = None  # type: ignore[assignment]\n\n                ts = run.traces\n                # pick x axis name\n                xname = getattr(ts.x, \"name\", \"time\")\n                for name in y:\n                    vals = ts[name].values\n                    if sample_at is not None and _np is not None and xname.lower() == \"time\":\n                        t = ts[xname].values\n                        row[name] = float(_np.interp(sample_at, t, vals))\n                    else:\n                        row[name] = (\n                            float(vals[-1]) if len(vals) else _np.nan if _np is not None else 0.0\n                        )\n            rows.append(row)\n        return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.MonteCarloResult.to_dataframe","title":"<code>to_dataframe(metric=None, *, trial_name='trial', param_prefix='', y=None, sample_at=None)</code>","text":"Returns a per-trial DataFrame with columns <ul> <li>trial (index within this Monte Carlo run)</li> <li>one column per sampled parameter (from <code>samples</code>), optionally prefixed</li> <li>optional metric columns computed from each AnalysisResult</li> <li>optional raw trace columns (final value or sampled at <code>sample_at</code> seconds)</li> </ul> metric <ul> <li>callable \u2192 result stored in column 'metric' (float or scalar)</li> <li>mapping name-&gt;callable \u2192 adds one column per metric name</li> </ul> <p>y: list of trace names to extract values for each run. If <code>sample_at</code> is given,    the value is linearly interpolated at t=sample_at using the run's time axis;    otherwise, the last value in the trace is used.</p> Source code in <code>src/cat/analysis/montecarlo.py</code> <pre><code>def to_dataframe(\n    self,\n    metric: (\n        Callable[[AnalysisResult], float | dict[str, Any]]\n        | TMapping[str, Callable[[AnalysisResult], Any]]\n        | None\n    ) = None,\n    *,\n    trial_name: str = \"trial\",\n    param_prefix: str = \"\",\n    y: Sequence[str] | None = None,\n    sample_at: float | None = None,\n) -&gt; Any:\n    \"\"\"\n    Returns a per-trial DataFrame with columns:\n      - trial (index within this Monte Carlo run)\n      - one column per sampled parameter (from `samples`), optionally prefixed\n      - optional metric columns computed from each AnalysisResult\n      - optional raw trace columns (final value or sampled at `sample_at` seconds)\n\n    metric:\n      - callable \u2192 result stored in column 'metric' (float or scalar)\n      - mapping name-&gt;callable \u2192 adds one column per metric name\n    y: list of trace names to extract values for each run. If `sample_at` is given,\n       the value is linearly interpolated at t=sample_at using the run's time axis;\n       otherwise, the last value in the trace is used.\n    \"\"\"\n    try:\n        pd: Any = importlib.import_module(\"pandas\")\n    except Exception as exc:  # pragma: no cover\n        raise RuntimeError(\"pandas is required for MonteCarloResult.to_dataframe()\") from exc\n\n    rows: list[dict[str, Any]] = []\n    for i, (s, run) in enumerate(zip(self.samples, self.runs, strict=False)):\n        # copy sampled params; optionally add prefix\n        if param_prefix:\n            row = {f\"{param_prefix}{k}\": v for k, v in s.items()}\n        else:\n            row = dict(s)\n        row[trial_name] = i\n        if metric is not None:\n            if hasattr(metric, \"items\"):\n                for name, fn in cast(\n                    TMapping[str, Callable[[AnalysisResult], Any]], metric\n                ).items():\n                    row[name] = fn(run)\n            else:\n                m = cast(Callable[[AnalysisResult], Any], metric)(run)\n                if isinstance(m, dict):\n                    row.update(m)\n                else:\n                    row[\"metric\"] = m\n\n        if y:\n            try:\n                import numpy as _np  # local import to avoid hard dep at module import\n            except Exception:  # pragma: no cover\n                _np = None  # type: ignore[assignment]\n\n            ts = run.traces\n            # pick x axis name\n            xname = getattr(ts.x, \"name\", \"time\")\n            for name in y:\n                vals = ts[name].values\n                if sample_at is not None and _np is not None and xname.lower() == \"time\":\n                    t = ts[xname].values\n                    row[name] = float(_np.interp(sample_at, t, vals))\n                else:\n                    row[name] = (\n                        float(vals[-1]) if len(vals) else _np.nan if _np is not None else 0.0\n                    )\n        rows.append(row)\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.RiseFall","title":"<code>RiseFall</code>  <code>dataclass</code>","text":"<p>Tempos de subida/descida entre fra\u00e7\u00f5es de n\u00edvel (ex.: 10%\u219290%).</p> Source code in <code>src/cat/analysis/metrics_tran.py</code> <pre><code>@dataclass(frozen=True)\nclass RiseFall:\n    \"\"\"Tempos de subida/descida entre fra\u00e7\u00f5es de n\u00edvel (ex.: 10%\u219290%).\"\"\"\n\n    trise: float | None\n    tfall: float | None\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.ac_gain_phase","title":"<code>ac_gain_phase(ts, y_out, y_in=None)</code>","text":"<p>Retorna (f, mag_db, fase_deg).</p> Source code in <code>src/cat/analysis/metrics_ac.py</code> <pre><code>def ac_gain_phase(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str | None = None,\n) -&gt; tuple[NDArray[Any], NDArray[Any], NDArray[Any]]:\n    \"\"\"Retorna (f, mag_db, fase_deg).\"\"\"\n    return _get_xy_ac(ts, y_out=y_out, y_in=y_in)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.bandwidth_3db","title":"<code>bandwidth_3db(ts, y_out, y_in=None)</code>","text":"<p>Frequ\u00eancia -3 dB relativa ao ganho de baixa frequ\u00eancia.</p> Source code in <code>src/cat/analysis/metrics_ac.py</code> <pre><code>def bandwidth_3db(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str | None = None,\n) -&gt; float | None:\n    \"\"\"Frequ\u00eancia -3 dB relativa ao ganho de baixa frequ\u00eancia.\"\"\"\n    f, mag_db, _ = ac_gain_phase(ts, y_out=y_out, y_in=y_in)\n    g0 = float(mag_db[0])\n    target = g0 - 3.0\n    below = np.where(mag_db &lt;= target)[0]\n    if below.size == 0:\n        return None\n    i = below[0]\n    if i == 0:\n        return float(f[0])\n    x0, x1 = f[i - 1], f[i]\n    y0, y1 = mag_db[i - 1], mag_db[i]\n    if np.isclose(y1, y0):\n        return float(x1)\n    w = (target - y0) / (y1 - y0)\n    return float(x0 + w * (x1 - x0))\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.bode","title":"<code>bode(circuit, y_out, y_in=None, *, sweep_type='dec', n=201, fstart=10.0, fstop=1000000.0)</code>","text":"<p>Run AC and return (f, |G|_dB, phase_deg) using cat.analysis.metrics_ac.</p> <p>Note: The circuit must include appropriate small-signal sources for AC analysis.</p> Source code in <code>src/cat/analysis/__init__.py</code> <pre><code>def bode(\n    circuit: Circuit,\n    y_out: str,\n    y_in: str | None = None,\n    *,\n    sweep_type: str = \"dec\",\n    n: int = 201,\n    fstart: float = 10.0,\n    fstop: float = 1e6,\n) -&gt; tuple[Any, Any, Any]:\n    \"\"\"Run AC and return (f, |G|_dB, phase_deg) using cat.analysis.metrics_ac.\n\n    Note: The circuit must include appropriate small-signal sources for AC analysis.\n    \"\"\"\n    res = AC(sweep_type, n, fstart, fstop).run(circuit)\n    return ac_gain_phase(res.traces, y_out=y_out, y_in=y_in)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.crossover_freq_0db","title":"<code>crossover_freq_0db(ts, y_out, y_in=None)</code>","text":"<p>Frequ\u00eancia em que |G| cruza 0 dB.</p> Source code in <code>src/cat/analysis/metrics_ac.py</code> <pre><code>def crossover_freq_0db(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str | None = None,\n) -&gt; float | None:\n    \"\"\"Frequ\u00eancia em que |G| cruza 0 dB.\"\"\"\n    f, mag_db, _ = ac_gain_phase(ts, y_out=y_out, y_in=y_in)\n    y = mag_db\n    s = np.sign(y)\n    idx = np.where((s[:-1] &gt;= 0) &amp; (s[1:] &lt;= 0) | (s[:-1] &lt;= 0) &amp; (s[1:] &gt;= 0))[0]\n    if idx.size == 0:\n        return None\n    i = int(idx[0])\n    x0, x1 = f[i], f[i + 1]\n    y0, y1 = y[i], y[i + 1]\n    if np.isclose(y1, y0):\n        return float(x0)\n    w = (0.0 - y0) / (y1 - y0)\n    return float(x0 + w * (x1 - x0))\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.fall_time","title":"<code>fall_time(ts, y_name, frac_low=0.1, frac_high=0.9)</code>","text":"<p>Tempo 90\u201310% (por padr\u00e3o). Retorna RiseFall com .tfall (e .trise=None).</p> <p>Estrat\u00e9gia robusta an\u00e1loga \u00e0 de subida, mas do n\u00edvel alto para o baixo.</p> Source code in <code>src/cat/analysis/metrics_tran.py</code> <pre><code>def fall_time(\n    ts: TraceSet,\n    y_name: str,\n    frac_low: float = 0.1,\n    frac_high: float = 0.9,\n) -&gt; RiseFall:\n    \"\"\"\n    Tempo 90\u201310% (por padr\u00e3o). Retorna RiseFall com .tfall (e .trise=None).\n\n    Estrat\u00e9gia robusta an\u00e1loga \u00e0 de subida, mas do n\u00edvel alto para o baixo.\n    \"\"\"\n    x, y = _get_xy(ts, y_name)\n    y0 = float(y[0])\n    yf = float(y[-1])\n    y_min = float(np.min(y))\n    y_max = float(np.max(y))\n    span_end = y0 - yf\n    span_global = y_max - y_min\n\n    if span_end &gt; 1e-15:\n        hi = yf + (1.0 - frac_high) * span_end  # pr\u00f3ximo de y0\n        lo = yf + (1.0 - frac_low) * span_end\n    elif span_global &gt; 1e-15:\n        hi = y_max - frac_high * span_global\n        lo = y_max - frac_low * span_global\n    else:\n        return RiseFall(trise=None, tfall=None)\n\n    t_hi = _cross_time(x, y, hi)\n    t_lo = _cross_time(x, y, lo)\n\n    if t_hi is None:\n        t_hi = _interp_time_fall(x, y, hi)\n    if t_lo is None:\n        t_lo = _interp_time_fall(x, y, lo)\n\n    if t_hi is None:\n        t_hi = _discrete_time_first_at_or_above(x, y[::-1], hi)\n    if t_lo is None:\n        t_lo = _discrete_time_first_at_or_above(x, y[::-1], lo)\n\n    if t_hi is None or t_lo is None:\n        return RiseFall(trise=None, tfall=None)\n\n    dt = float(t_lo - t_hi)\n    if dt &lt; 0.0:\n        dt = 0.0\n    return RiseFall(trise=None, tfall=dt)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.gain_at","title":"<code>gain_at(ts, y_out, f_hz, y_in=None)</code>","text":"<p>Ganho (dB) em f_hz.</p> Source code in <code>src/cat/analysis/metrics_ac.py</code> <pre><code>def gain_at(\n    ts: TraceSet,\n    y_out: str,\n    f_hz: float,\n    y_in: str | None = None,\n) -&gt; float:\n    \"\"\"Ganho (dB) em f_hz.\"\"\"\n    f, mag_db, _ = ac_gain_phase(ts, y_out=y_out, y_in=y_in)\n    return _interp_at_x(f, mag_db, f_hz)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.gain_db_from_traces","title":"<code>gain_db_from_traces(ts, y_name)</code>","text":"<p>\"Ganho\" DC aproximado, usando a diferen\u00e7a final - inicial do tra\u00e7o (em dB do delta). \u00c9 um helper simples para testes; n\u00e3o \u00e9 igual a ganho AC.</p> Source code in <code>src/cat/analysis/metrics_basic.py</code> <pre><code>def gain_db_from_traces(ts: TraceSet, y_name: str) -&gt; float:\n    \"\"\"\n    \"Ganho\" DC aproximado, usando a diferen\u00e7a final - inicial do tra\u00e7o (em dB do delta).\n    \u00c9 um helper simples para testes; n\u00e3o \u00e9 igual a ganho AC.\n    \"\"\"\n    arr = _vals(ts, y_name)\n    if arr.size == 0:\n        return -300.0\n    v = float(arr[-1] - arr[0])\n    if v == 0.0:\n        return -300.0\n    return float(20.0 * np.log10(abs(v)))\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.gain_margin_db","title":"<code>gain_margin_db(ts, y_out, y_in=None)</code>","text":"<p>Ganho em dB quando fase = -180\u00b0 (margem de ganho).</p> Source code in <code>src/cat/analysis/metrics_ac.py</code> <pre><code>def gain_margin_db(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str | None = None,\n) -&gt; float | None:\n    \"\"\"Ganho em dB quando fase = -180\u00b0 (margem de ganho).\"\"\"\n    f180 = phase_crossover_freq(ts, y_out=y_out, y_in=y_in, target_deg=-180.0)\n    if f180 is None:\n        return None\n    return gain_at(ts, y_out=y_out, y_in=y_in, f_hz=f180)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.loop_gain_bode","title":"<code>loop_gain_bode(ts, y_out, y_in)</code>","text":"<p>Retorna Bode do loop (y_out / y_in) como tupla (f, mag_db, fase).</p> Source code in <code>src/cat/analysis/metrics_ac.py</code> <pre><code>def loop_gain_bode(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str,\n) -&gt; tuple[NDArray[Any], NDArray[Any], NDArray[Any]]:\n    \"\"\"Retorna Bode do loop (y_out / y_in) como tupla (f, mag_db, fase).\"\"\"\n    return ac_gain_phase(ts, y_out=y_out, y_in=y_in)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.monte_carlo","title":"<code>monte_carlo(circuit, mapping, n, analysis_factory, seed=None, label_fn=None, workers=1, progress=None)</code>","text":"<p>Executa Monte Carlo variando valores dos componentes conforme distribui\u00e7\u00f5es.</p> Source code in <code>src/cat/analysis/montecarlo.py</code> <pre><code>def monte_carlo(\n    circuit: Circuit,\n    mapping: Mapping[Component, Dist],\n    n: int,\n    analysis_factory: Callable[[], _RunsAnalysis],\n    seed: int | None = None,\n    label_fn: Callable[[Component], str] | None = None,\n    workers: int = 1,\n    progress: bool | Callable[[int, int], None] | None = None,\n) -&gt; MonteCarloResult:\n    \"\"\"\n    Executa Monte Carlo variando valores dos componentes conforme distribui\u00e7\u00f5es.\n    \"\"\"\n    rnd = _random.Random(seed)\n\n    def _label(c: Component) -&gt; str:\n        if label_fn:\n            return label_fn(c)\n        return f\"{type(c).__name__}.{c.ref}\"\n\n    comps: list[Component] = list(mapping.keys())\n    nominals: list[float] = [_as_float(c.value) for c in comps]\n    dists: list[Dist] = [mapping[c] for c in comps]\n\n    samples: list[dict[str, float]] = []\n    for _ in range(n):\n        s: dict[str, float] = {}\n        for comp, nominal, dist in zip(comps, nominals, dists, strict=False):\n            s[_label(comp)] = dist.sample(nominal, rnd)\n        samples.append(s)\n\n    def _run_one(sample: dict[str, float]) -&gt; AnalysisResult:\n        c_copy: Circuit = copy.deepcopy(circuit)\n        comp_list = getattr(c_copy, \"components\", None)\n        if comp_list is None:\n            comp_list = getattr(c_copy, \"_components\", [])\n        by_label: dict[str, Component] = {_label(c): c for c in comp_list}\n        for k, v in sample.items():\n            by_label[k].value = v\n        analysis = analysis_factory()\n        return analysis.run(c_copy)\n\n    # Progress handler (optional)\n    printer = None\n\n    def _notify(done: int, total: int) -&gt; None:\n        if progress is None:\n            return\n        if callable(progress):\n            try:\n                progress(done, total)\n            except Exception:\n                pass\n            return\n        # simple stderr bar\n        nonlocal printer\n        if progress is True:\n            # lazy-init\n            class _Bar:\n                def __init__(self, total: int) -&gt; None:\n                    self.total = total\n                    self.last = -1\n\n                def update(self, done: int) -&gt; None:\n                    if done == self.last:\n                        return\n                    pct = int(round(100.0 * done / max(self.total, 1)))\n                    sys.stderr.write(f\"\\rMC: {done}/{self.total} ({pct}%)\")\n                    sys.stderr.flush()\n                    self.last = done\n\n                def close(self) -&gt; None:\n                    sys.stderr.write(\"\\n\")\n\n            if printer is None:\n                printer = _Bar(total)\n            printer.update(done)\n\n    runs: list[AnalysisResult] = []\n    if workers &lt;= 1:\n        for i, s in enumerate(samples, start=1):\n            runs.append(_run_one(s))\n            _notify(i, len(samples))\n    else:\n        # Executa em paralelo preservando a ordem dos samples\n        runs_buf: list[AnalysisResult | None] = [None] * len(samples)\n        with ThreadPoolExecutor(max_workers=workers) as ex:\n            fut_to_idx = {}\n            for idx, s in enumerate(samples):\n                fut = ex.submit(_run_one, s)\n                fut_to_idx[fut] = idx\n            done = 0\n            for f in as_completed(list(fut_to_idx.keys())):\n                idx = fut_to_idx[f]\n                runs_buf[idx] = f.result()\n                done += 1\n                _notify(done, len(samples))\n        runs = [r for r in runs_buf if r is not None]\n\n    if isinstance(progress, bool) and progress and printer is not None:\n        try:\n            printer.close()\n        except Exception:\n            pass\n\n    return MonteCarloResult(samples=samples, runs=runs)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.overshoot","title":"<code>overshoot(ts, y_name)</code>","text":"<p>Overshoot relativo ao degrau: (Vmax - Vfinal) / (Vfinal - Vinicial).</p> Source code in <code>src/cat/analysis/metrics_tran.py</code> <pre><code>def overshoot(ts: TraceSet, y_name: str) -&gt; OvershootResult:\n    \"\"\"\n    Overshoot relativo ao degrau: (Vmax - Vfinal) / (Vfinal - Vinicial).\n    \"\"\"\n    x, y = _get_xy(ts, y_name)\n    _ = x  # reservado para futuros usos\n    n = y.shape[0]\n    if n &lt; 2:\n        return OvershootResult(\n            overshoot=0.0,\n            y_final=float(y[-1]),\n            y_initial=float(y[0]),\n            y_peak=float(y[0]),\n        )\n    y0 = float(y[0])\n    yf = float(y[-1])\n    yp = float(np.max(y))\n    denom = yf - y0\n    if np.isclose(denom, 0.0):\n        return OvershootResult(overshoot=0.0, y_final=yf, y_initial=y0, y_peak=yp)\n    ov = max(0.0, (yp - yf) / denom)\n    return OvershootResult(overshoot=ov, y_final=yf, y_initial=y0, y_peak=yp)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.overshoot_pct","title":"<code>overshoot_pct(ts, y_name)</code>","text":"<p>Overshoot em % relativo ao degrau.</p> Source code in <code>src/cat/analysis/metrics_basic.py</code> <pre><code>def overshoot_pct(ts: TraceSet, y_name: str) -&gt; float:\n    \"\"\"Overshoot em % relativo ao degrau.\"\"\"\n    return float(_ov(ts, y_name).overshoot * 100.0)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.phase_crossover_freq","title":"<code>phase_crossover_freq(ts, y_out, y_in=None, target_deg=-180.0)</code>","text":"<p>Frequ\u00eancia em que fase cruza target (padr\u00e3o: -180\u00b0).</p> Source code in <code>src/cat/analysis/metrics_ac.py</code> <pre><code>def phase_crossover_freq(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str | None = None,\n    target_deg: float = -180.0,\n) -&gt; float | None:\n    \"\"\"Frequ\u00eancia em que fase cruza target (padr\u00e3o: -180\u00b0).\"\"\"\n    f, _, ph_deg = ac_gain_phase(ts, y_out=y_out, y_in=y_in)\n    y = ph_deg - target_deg\n    s = np.sign(y)\n    idx = np.where((s[:-1] &gt;= 0) &amp; (s[1:] &lt;= 0) | (s[:-1] &lt;= 0) &amp; (s[1:] &gt;= 0))[0]\n    if idx.size == 0:\n        return None\n    i = int(idx[0])\n    x0, x1 = f[i], f[i + 1]\n    y0, y1 = y[i], y[i + 1]\n    if np.isclose(y1, y0):\n        return float(x0)\n    w = (0.0 - y0) / (y1 - y0)\n    return float(x0 + w * (x1 - x0))\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.phase_margin","title":"<code>phase_margin(ts, y_out, y_in=None)</code>","text":"<p>PM = 180\u00b0 + fase em w_c (onde |G|=1). Fase normalizada para (-180, 180].</p> <p>Fallback: se a fase aparenta estar ausente (vari\u00e2ncia ~ zero), estima PM assumindo um sistema de 1 polo m\u00ednimo-fase: \u03c6(w) \u2248 -atan(w/wp) e PM \u2248 180\u00b0 - atan(wc/wp), onde wp \u00e9 obtido via largura de banda de -3 dB.</p> Source code in <code>src/cat/analysis/metrics_ac.py</code> <pre><code>def phase_margin(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str | None = None,\n) -&gt; float | None:\n    \"\"\"\n    PM = 180\u00b0 + fase em w_c (onde |G|=1). Fase normalizada para (-180, 180].\n\n    Fallback: se a fase aparenta estar ausente (vari\u00e2ncia ~ zero), estima PM assumindo\n    um sistema de 1 polo m\u00ednimo-fase: \u03c6(w) \u2248 -atan(w/wp) e PM \u2248 180\u00b0 - atan(wc/wp),\n    onde wp \u00e9 obtido via largura de banda de -3 dB.\n    \"\"\"\n    wc = crossover_freq_0db(ts, y_out=y_out, y_in=y_in)\n    if wc is None:\n        return None\n    f, _, ph = ac_gain_phase(ts, y_out=y_out, y_in=y_in)\n\n    # se h\u00e1 fase, use-a\n    if np.nanstd(ph) &gt; 1e-3:\n        phi = _interp_at_x(f, ph, wc)\n        return 180.0 + float(phi)\n\n    # fallback 1-polo: usa -3 dB para estimar wp\n    bw = bandwidth_3db(ts, y_out=y_out, y_in=y_in)\n    if bw is None or bw &lt;= 0.0:\n        # sem alternativa: devolve 180 para n\u00e3o explodir\n        return 180.0\n    phi_est = -np.degrees(np.arctan(wc / bw))\n    return 180.0 + float(phi_est)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.rise_time","title":"<code>rise_time(ts, y_name, frac_low=0.1, frac_high=0.9)</code>","text":"<p>Tempo 10\u201390% (por padr\u00e3o). Retorna RiseFall com .trise (e .tfall=None).</p> Estrat\u00e9gia robusta <p>1) Prioriza n\u00edveis com base em y0\u2192yf (degrau observado). Se n\u00e3o subir, usa span global. 2) Tenta cruzamento linear; se falhar, interpola no envelope; se falhar, usa fallback    discreto (primeiro \u00edndice com y &gt;= n\u00edvel).</p> Source code in <code>src/cat/analysis/metrics_tran.py</code> <pre><code>def rise_time(\n    ts: TraceSet,\n    y_name: str,\n    frac_low: float = 0.1,\n    frac_high: float = 0.9,\n) -&gt; RiseFall:\n    \"\"\"\n    Tempo 10\u201390% (por padr\u00e3o). Retorna RiseFall com .trise (e .tfall=None).\n\n    Estrat\u00e9gia robusta:\n      1) Prioriza n\u00edveis com base em y0\u2192yf (degrau observado). Se n\u00e3o subir, usa span global.\n      2) Tenta cruzamento linear; se falhar, interpola no envelope; se falhar, usa fallback\n         discreto (primeiro \u00edndice com y &gt;= n\u00edvel).\n    \"\"\"\n    x, y = _get_xy(ts, y_name)\n    y0 = float(y[0])\n    yf = float(y[-1])\n    y_min = float(np.min(y))\n    y_max = float(np.max(y))\n    span_end = yf - y0\n    span_global = y_max - y_min\n\n    if span_end &gt; 1e-15:\n        lo = y0 + frac_low * span_end\n        hi = y0 + frac_high * span_end\n    elif span_global &gt; 1e-15:\n        lo = y_min + frac_low * span_global\n        hi = y_min + frac_high * span_global\n    else:\n        return RiseFall(trise=None, tfall=None)\n\n    # 1) cruzamento linear\n    t_lo = _cross_time(x, y, lo)\n    t_hi = _cross_time(x, y, hi)\n\n    # 2) envelope (n\u00e3o-decrescente)\n    if t_lo is None:\n        t_lo = _interp_time_rise(x, y, lo)\n    if t_hi is None:\n        t_hi = _interp_time_rise(x, y, hi)\n\n    # 3) discreto (primeiro \u00edndice com y &gt;= n\u00edvel)\n    if t_lo is None:\n        t_lo = _discrete_time_first_at_or_above(x, y, lo)\n    if t_hi is None:\n        t_hi = _discrete_time_first_at_or_above(x, y, hi)\n\n    if t_lo is None or t_hi is None:\n        return RiseFall(trise=None, tfall=None)\n\n    dt = float(t_hi - t_lo)\n    if dt &lt; 0.0:\n        dt = 0.0\n    return RiseFall(trise=dt, tfall=None)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.run_ac","title":"<code>run_ac(circuit, sweep_type, n, fstart, fstop, *, return_df=False)</code>","text":"<p>Run an AC analysis and optionally return a DataFrame of traces.</p> Source code in <code>src/cat/analysis/__init__.py</code> <pre><code>def run_ac(\n    circuit: Circuit,\n    sweep_type: str,\n    n: int,\n    fstart: float,\n    fstop: float,\n    *,\n    return_df: bool = False,\n) -&gt; AnalysisResult | Any:\n    \"\"\"Run an AC analysis and optionally return a DataFrame of traces.\"\"\"\n    res = AC(sweep_type, n, fstart, fstop).run(circuit)\n    if return_df:\n        return res.traces.to_dataframe()\n    return res\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.run_op","title":"<code>run_op(circuit)</code>","text":"<p>Run a simple .OP analysis and return the AnalysisResult.</p> Example <p>from cat.core.circuit import Circuit from cat.core.components import Vdc, Resistor from cat.core.net import GND c = Circuit(\"rc\") V1, R1 = Vdc(\"1\", 5.0), Resistor(\"1\", \"1k\") c.add(V1, R1) c.connect(V1.ports[0], R1.ports[0]) c.connect(R1.ports[1], GND) c.connect(V1.ports[1], GND) _ = run_op(c)  # doctest: +SKIP</p> Source code in <code>src/cat/analysis/__init__.py</code> <pre><code>def run_op(circuit: Circuit) -&gt; AnalysisResult:\n    \"\"\"Run a simple .OP analysis and return the AnalysisResult.\n\n    Example:\n        &gt;&gt;&gt; from cat.core.circuit import Circuit\n        &gt;&gt;&gt; from cat.core.components import Vdc, Resistor\n        &gt;&gt;&gt; from cat.core.net import GND\n        &gt;&gt;&gt; c = Circuit(\"rc\")\n        &gt;&gt;&gt; V1, R1 = Vdc(\"1\", 5.0), Resistor(\"1\", \"1k\")\n        &gt;&gt;&gt; c.add(V1, R1)\n        &gt;&gt;&gt; c.connect(V1.ports[0], R1.ports[0])\n        &gt;&gt;&gt; c.connect(R1.ports[1], GND)\n        &gt;&gt;&gt; c.connect(V1.ports[1], GND)\n        &gt;&gt;&gt; _ = run_op(c)  # doctest: +SKIP\n    \"\"\"\n    return OP().run(circuit)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.run_step_native","title":"<code>run_step_native(circuit, directives)</code>","text":"<p>Roda um deck com diretivas .step nativas (j\u00e1 contidas em <code>directives</code>) e retorna todos os plots como lista de TraceSet.</p> Source code in <code>src/cat/analysis/step_native.py</code> <pre><code>def run_step_native(circuit: Circuit, directives: list[str]) -&gt; StepNativeResult:\n    \"\"\"\n    Roda um deck com diretivas .step nativas (j\u00e1 contidas em `directives`)\n    e retorna todos os plots como lista de TraceSet.\n    \"\"\"\n    net = circuit.build_netlist()\n    run_directives = get_run_directives()\n    res = run_directives(net, directives)\n    if res.returncode != 0 or not res.artifacts.raw_path:\n        raise RuntimeError(\"NGSpice failed for native .step run\")\n    sets = parse_ngspice_ascii_raw_multi(res.artifacts.raw_path)\n    return StepNativeResult(tracesets=sets)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.run_tran","title":"<code>run_tran(circuit, tstep, tstop, tstart=None, *, return_df=False)</code>","text":"<p>Run a transient (.TRAN) analysis and optionally return a Pandas DataFrame.</p> <ul> <li>return_df=False returns AnalysisResult</li> <li>return_df=True returns a DataFrame via TraceSet.to_dataframe()</li> </ul> Source code in <code>src/cat/analysis/__init__.py</code> <pre><code>def run_tran(\n    circuit: Circuit,\n    tstep: str,\n    tstop: str,\n    tstart: str | None = None,\n    *,\n    return_df: bool = False,\n) -&gt; AnalysisResult | Any:\n    \"\"\"Run a transient (.TRAN) analysis and optionally return a Pandas DataFrame.\n\n    - return_df=False returns AnalysisResult\n    - return_df=True returns a DataFrame via TraceSet.to_dataframe()\n    \"\"\"\n    res = TRAN(tstep, tstop, tstart).run(circuit)\n    if return_df:\n        return res.traces.to_dataframe()\n    return res\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.settling_time","title":"<code>settling_time(ts, y_name, tol=0.02)</code>","text":"<p>Primeiro instante em que |y(t) - y_final| &lt;= tol*|y_final - y_initial| e permanece assim at\u00e9 o final.</p> Source code in <code>src/cat/analysis/metrics_tran.py</code> <pre><code>def settling_time(ts: TraceSet, y_name: str, tol: float = 0.02) -&gt; SettlingResult:\n    \"\"\"\n    Primeiro instante em que |y(t) - y_final| &lt;= tol*|y_final - y_initial|\n    e permanece assim at\u00e9 o final.\n    \"\"\"\n    x, y = _get_xy(ts, y_name)\n    y0 = float(y[0])\n    yf = float(y[-1])\n    band = abs(tol * (yf - y0))\n    if band == 0.0:\n        return SettlingResult(t_settle=None, idx=None, band=band, y_final=yf)\n\n    err = np.abs(y - yf)\n    inside = err &lt;= band\n    suffix_ok = np.flip(np.cumsum(np.flip(~inside)) == 0)\n    ok = inside &amp; suffix_ok\n    idxs = np.where(ok)[0]\n    if idxs.size == 0:\n        return SettlingResult(t_settle=None, idx=None, band=band, y_final=yf)\n    i = int(idxs[0])\n    return SettlingResult(t_settle=float(x[i]), idx=i, band=band, y_final=yf)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.stack_runs_to_df","title":"<code>stack_runs_to_df(runs, params_list=None, y=None, with_x=True, run_index_name='run_idx')</code>","text":"<p>Empilha uma lista de <code>AnalysisResult</code> em um \u00fanico DataFrame, adicionando as colunas de par\u00e2metros (<code>params_list[i]</code>) por run.</p> <ul> <li><code>y</code>: lista de nomes de tra\u00e7os a manter (ex.: [\"v(out)\"]). Se None, mant\u00e9m todos.</li> <li><code>with_x</code>: inclui a coluna do eixo X (primeira coluna do TraceSet), tipicamente \"time\"/\"frequency\".</li> </ul> Source code in <code>src/cat/analysis/post.py</code> <pre><code>def stack_runs_to_df(\n    runs: Sequence[AnalysisResult],\n    params_list: Sequence[Mapping[str, str | float]] | None = None,\n    y: Sequence[str] | None = None,\n    with_x: bool = True,\n    run_index_name: str = \"run_idx\",\n) -&gt; Any:\n    \"\"\"\n    Empilha uma lista de `AnalysisResult` em um \u00fanico DataFrame, adicionando\n    as colunas de par\u00e2metros (`params_list[i]`) por run.\n\n    - `y`: lista de nomes de tra\u00e7os a manter (ex.: [\"v(out)\"]). Se None, mant\u00e9m todos.\n    - `with_x`: inclui a coluna do eixo X (primeira coluna do TraceSet), tipicamente\n    \"time\"/\"frequency\".\n    \"\"\"\n    pd = _ensure_pandas()\n    frames: list[Any] = []\n    for i, res in enumerate(runs):\n        df = res.traces.to_dataframe()\n        x_name = res.traces.x.name\n        keep = list(df.columns)\n        if y is not None:\n            keep = [x_name] + list(y) if with_x else list(y)\n            df = _pick_columns(df, keep)\n        else:\n            if not with_x:\n                keep = [c for c in keep if c != x_name]\n                df = df[keep]\n        # par\u00e2metros deste run\n        params = params_list[i] if params_list is not None else {}\n        for k, v in params.items():\n            df[k] = v\n        df[run_index_name] = i\n        frames.append(df)\n    if not frames:\n        return pd.DataFrame()\n    return pd.concat(frames, ignore_index=True)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.stack_step_to_df","title":"<code>stack_step_to_df(step, y=None, with_x=True, run_index_name='run_idx')</code>","text":"<p>Vers\u00e3o pr\u00e1tica para <code>StepResult</code>: empilha <code>step.runs</code> com as colunas de <code>step.grid</code>.</p> Source code in <code>src/cat/analysis/post.py</code> <pre><code>def stack_step_to_df(\n    step: StepResult,\n    y: Sequence[str] | None = None,\n    with_x: bool = True,\n    run_index_name: str = \"run_idx\",\n) -&gt; Any:\n    \"\"\"\n    Vers\u00e3o pr\u00e1tica para `StepResult`: empilha `step.runs` com as colunas de `step.grid`.\n    \"\"\"\n    return stack_runs_to_df(step.runs, step.grid, y=y, with_x=with_x, run_index_name=run_index_name)\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.sweep_component","title":"<code>sweep_component(circuit, component, values, analysis_factory, param_name=None, *, progress=None)</code>","text":"<p>Executa v\u00e1rias simula\u00e7\u00f5es alterando <code>component.value</code> em Python.</p> <ul> <li><code>values</code>: lista de valores a aplicar no componente (ex.: [\"1k\",\"2k\",\"5k\"])</li> <li><code>analysis_factory</code>: callable que cria uma inst\u00e2ncia da an\u00e1lise a cada itera\u00e7\u00e3o,   por ex.: <code>lambda: TRAN(\"100us\",\"1ms\")</code> ou <code>lambda: OP()</code></li> <li><code>param_name</code>: opcional, nome amig\u00e1vel para registrar no resultado</li> </ul> Source code in <code>src/cat/analysis/sweep.py</code> <pre><code>def sweep_component(\n    circuit: Circuit,\n    component: Component,\n    values: Sequence[str | float],\n    analysis_factory: Callable[[], A],\n    param_name: str | None = None,\n    *,\n    progress: bool | Callable[[int, int], None] | None = None,\n) -&gt; SweepResult:\n    \"\"\"Executa v\u00e1rias simula\u00e7\u00f5es alterando `component.value` em Python.\n\n    - `values`: lista de valores a aplicar no componente (ex.: [\"1k\",\"2k\",\"5k\"])\n    - `analysis_factory`: callable que cria uma inst\u00e2ncia da an\u00e1lise a cada itera\u00e7\u00e3o,\n      por ex.: `lambda: TRAN(\"100us\",\"1ms\")` ou `lambda: OP()`\n    - `param_name`: opcional, nome amig\u00e1vel para registrar no resultado\n    \"\"\"\n    original = component.value\n\n    def _notify(done: int) -&gt; None:\n        if not progress:\n            return\n        if callable(progress):\n            try:\n                progress(done, len(values))\n            except Exception:\n                pass\n            return\n        pct = int(round(100.0 * done / max(len(values), 1)))\n        sys.stderr.write(f\"\\rSWEEP[{component.ref}]: {done}/{len(values)} ({pct}%)\")\n        sys.stderr.flush()\n\n    runs: list[AnalysisResult] = []\n    try:\n        for i, v in enumerate(values, start=1):\n            component.value = v\n            analysis = analysis_factory()\n            res = analysis.run(circuit)  # type: ignore[attr-defined]\n            runs.append(res)\n            _notify(i)\n    finally:\n        component.value = original  # restore\n    return SweepResult(\n        param_name or f\"{type(component).__name__}.{component.ref}\", list(values), runs\n    )\n</code></pre>"},{"location":"reference/analysis/#cat.analysis.worst_case","title":"<code>worst_case(circuit, analysis_factory, metric, space, mode='min', n_random=64, n_refine=3, progress=None)</code>","text":"<p>Busca pior caso sobre par\u00e2metros .param discretizados em 'space'. Estrat\u00e9gia: amostragem aleat\u00f3ria inicial -&gt; refinamento coordenado local.</p> Source code in <code>src/cat/analysis/worstcase.py</code> <pre><code>def worst_case(\n    circuit: Circuit,\n    analysis_factory: Callable[[], object],\n    metric: Callable[[AnalysisResult], float],\n    space: Mapping[str, Sequence[float | str]],\n    mode: str = \"min\",  # \"min\" or \"max\"\n    n_random: int = 64,\n    n_refine: int = 3,\n    progress: bool | Callable[[int, int], None] | None = None,\n) -&gt; WorstCaseResult:\n    \"\"\"\n    Busca pior caso sobre par\u00e2metros .param discretizados em 'space'.\n    Estrat\u00e9gia: amostragem aleat\u00f3ria inicial -&gt; refinamento coordenado local.\n    \"\"\"\n    net = circuit.build_netlist()\n    base = analysis_factory()._directives()  # type: ignore[attr-defined]\n\n    # 1) random\n    total = n_random + sum(len(space[k]) for k in space) * n_refine\n\n    def _notify(done: int) -&gt; None:\n        if not progress:\n            return\n        if callable(progress):\n            try:\n                progress(done, total)\n            except Exception:\n                pass\n            return\n        pct = int(round(100.0 * done / max(total, 1)))\n        sys.stderr.write(f\"\\rWORST: {done}/{total} ({pct}%)\")\n        sys.stderr.flush()\n\n    hist: list[tuple[dict[str, float | str], float]] = []\n    best_p: dict[str, float | str] = {}\n    best_v = math.inf if mode == \"min\" else -math.inf\n\n    keys = list(space.keys())\n    choices = [list(space[k]) for k in keys]\n\n    done = 0\n    for _ in range(n_random):\n        p = {k: random.choice(choices[i]) for i, k in enumerate(keys)}\n        res = _run_with_params(net, _directives_with_params(base, p))\n        val = metric(res)\n        hist.append((p, val))\n        if (mode == \"min\" and val &lt; best_v) or (mode == \"max\" and val &gt; best_v):\n            best_p, best_v = p, val\n        done += 1\n        _notify(done)\n\n    # 2) refinamento coordenado\n    for _ in range(n_refine):\n        improved = False\n        for i, k in enumerate(keys):\n            cand: list[tuple[float, dict[str, float | str]]] = []\n            for v in choices[i]:\n                p2 = dict(best_p)\n                p2[k] = v\n                res = _run_with_params(net, _directives_with_params(base, p2))\n                val = metric(res)\n                hist.append((p2, val))\n                cand.append((val, p2))\n                done += 1\n                _notify(done)\n            if mode == \"min\":\n                val, p_sel = min(cand, key=lambda x: x[0])\n                if val &lt; best_v:\n                    best_v, best_p, improved = val, p_sel, True\n            else:\n                val, p_sel = max(cand, key=lambda x: x[0])\n                if val &gt; best_v:\n                    best_v, best_p, improved = val, p_sel, True\n        if not improved:\n            break\n\n    return WorstCaseResult(best_params=best_p, best_value=best_v, history=hist)\n</code></pre>"},{"location":"reference/core/","title":"Core API","text":"<p>This section will be populated by <code>mkdocstrings</code> from the <code>cat.core</code> package.</p> <p>Example:</p> Source code in <code>src/cat/core/circuit.py</code> <pre><code>@dataclass\nclass Circuit:\n    name: str\n    _net_ids: dict[Net, int] = field(default_factory=dict, init=False)\n    _port_to_net: dict[Port, Net] = field(default_factory=dict, init=False)\n    _components: list[Component] = field(default_factory=list, init=False)\n    _directives: list[str] = field(default_factory=list, init=False)\n\n    def add(self, *comps: Component) -&gt; Circuit:\n        for c in comps:\n            self._components.append(c)\n        return self\n\n    def add_directive(self, line: str) -&gt; Circuit:\n        \"\"\"Append a raw SPICE directive (e.g., \".model ...\", \".param ...\").\"\"\"\n        self._directives.append(line.rstrip(\"\\n\"))\n        return self\n\n    def connect(self, a: Port, b: Net | Port) -&gt; Circuit:\n        if isinstance(b, Port):\n            # Port-Port connect: map both to a shared Net\n            na = self._port_to_net.get(a)\n            nb = self._port_to_net.get(b)\n            if na and nb and (na is not nb):\n                # merge: re-map all ports of nb to na\n                for p, n in list(self._port_to_net.items()):\n                    if n is nb:\n                        self._port_to_net[p] = na\n            else:\n                self._port_to_net[a] = na or nb or Net()\n                self._port_to_net[b] = self._port_to_net[a]\n        else:\n            # Port-Net\n            self._port_to_net[a] = b\n        return self\n\n    def _assign_node_ids(self) -&gt; None:\n        self._net_ids.clear()\n        # always ensure any logical GND (name == \"0\") maps to node id 0\n        # include the global GND sentinel for convenience\n        self._net_ids[GND] = 0\n        next_id = 1\n        for n in set(self._port_to_net.values()):\n            # treat any net named \"0\" as ground, not only the sentinel object\n            if (n is GND) or (getattr(n, \"name\", None) == \"0\"):\n                continue\n            if n not in self._net_ids:\n                self._net_ids[n] = next_id\n                next_id += 1\n\n    def _net_of(self, p: Port) -&gt; str:\n        n = self._port_to_net.get(p)\n        if n is None:\n            raise ValueError(f\"Unconnected port: {p.owner.ref}.{p.name}\")\n        node_id = self._net_ids.get(n)\n        if node_id is None:\n            raise RuntimeError(\"Node IDs not assigned.\")\n        # Preserve user-provided names for nets (except GND)\n        # treat any net named \"0\" as ground\n        if (n is GND) or (n.name == \"0\"):\n            return \"0\"\n        if n.name and n.name != \"0\":\n            return n.name\n        # auto-generate a name that avoids colliding with common user names (like 'n1')\n        return f\"net_{node_id}\"\n\n    def validate(self) -&gt; None:\n        # each component must have all ports connected\n        for comp in self._components:\n            for port in comp.ports:\n                if port not in self._port_to_net:\n                    raise ValueError(f\"Unconnected port: {comp.ref}.{port.name}\")\n\n    def build_netlist(self) -&gt; str:\n        self.validate()\n        self._assign_node_ids()\n        lines = [f\"* {self.name}\"]\n        for comp in self._components:\n            lines.append(comp.spice_card(self._net_of))\n        # Append directives (if any) before .end\n        for d in self._directives:\n            lines.append(d)\n        lines.append(\".end\")\n        return \"\\n\".join(lines)\n\n    # -----------------------------\n    # Introspection / Preview\n    # -----------------------------\n    def summary(self) -&gt; str:\n        \"\"\"Return a human-friendly connectivity summary and basic lint warnings.\"\"\"\n        # Map nets to connected ports (ref.port)\n        net_to_ports: dict[str, list[str]] = {}\n        unconnected: list[str] = []\n        # Ensure we have stable net names even if build wasn't called\n        # We'll map by object identity with temporary IDs\n        temp_ids: dict[Any, int] = {}\n        next_id = 1\n\n        def name_of_net(n: Net) -&gt; str:\n            nonlocal next_id\n            if n is GND:\n                return \"0\"\n            if n.name and n.name != \"0\":\n                return n.name\n            if n not in temp_ids:\n                temp_ids[n] = next_id\n                next_id += 1\n            return f\"n{temp_ids[n]}\"\n\n        for comp in self._components:\n            for port in comp.ports:\n                key = f\"{comp.ref}.{port.name}\"\n                n = self._port_to_net.get(port)\n                if n is None:\n                    unconnected.append(key)\n                else:\n                    nn = name_of_net(n)\n                    net_to_ports.setdefault(nn, []).append(key)\n\n        lines: list[str] = [f\"Circuit: {self.name}\"]\n        lines.append(\"Connections:\")\n        for nn, plist in sorted(net_to_ports.items()):\n            plist_sorted = \", \".join(sorted(plist))\n            lines.append(f\"  {nn}: {plist_sorted}\")\n\n        # Lint\n        warnings: list[str] = []\n        for nn, plist in net_to_ports.items():\n            if nn != \"0\" and len(plist) &lt;= 1:\n                warnings.append(f\"Net '{nn}' has degree {len(plist)} (possible floating)\")\n        if unconnected:\n            warnings.append(f\"Unconnected ports: {', '.join(sorted(unconnected))}\")\n        if warnings:\n            lines.append(\"Warnings:\")\n            for w in warnings:\n                lines.append(f\"  - {w}\")\n        return \"\\n\".join(lines)\n\n    def print_connectivity(self) -&gt; None:\n        print(self.summary())\n\n    def to_dot(self) -&gt; str:\n        \"\"\"Export a Graphviz DOT representation (components as boxes, nets as ellipses).\"\"\"\n        # Build stable names\n        self._assign_node_ids()\n        comp_ids: dict[Component, str] = {}\n        net_ids: dict[Net, str] = {}\n\n        def comp_id(c: Component) -&gt; str:\n            if c not in comp_ids:\n                comp_ids[c] = f\"comp_{c.ref}\"\n            return comp_ids[c]\n\n        def net_id(n: Net) -&gt; str:\n            if n not in net_ids:\n                if n is GND:\n                    net_ids[n] = \"net_0\"\n                else:\n                    name = n.name or f\"n{self._net_ids.get(n, 0)}\"\n                    safe = name.replace('\"', \"'\")\n                    net_ids[n] = f\"net_{safe}\"\n            return net_ids[n]\n\n        lines: list[str] = []\n        lines.append(\"graph circuit {\\n  rankdir=LR;\\n  node [fontname=Helvetica];\\n}\")\n        out: list[str] = [\"graph circuit {\", \"  rankdir=LR;\"]\n        # Net nodes\n        seen_nets: set[Net] = set()\n        for n in set(self._port_to_net.values()):\n            nid = net_id(n)\n            label = \"0\" if n is GND else (n.name or f\"n{self._net_ids.get(n, 0)}\")\n            if n is GND:\n                out.append(\n                    f'  {nid} [shape=ellipse, label=\"{label}\", style=filled, fillcolor=lightgray];'\n                )\n            else:\n                out.append(f'  {nid} [shape=ellipse, label=\"{label}\"];')\n            seen_nets.add(n)\n        # Component nodes\n        for c in self._components:\n            cid = comp_id(c)\n            val = str(c.value)\n            out.append(f'  {cid} [shape=box, label=\"{type(c).__name__} {c.ref}\\\\n{val}\"];')\n        # Edges\n        for c in self._components:\n            cid = comp_id(c)\n            for port in c.ports:\n                nn = self._port_to_net.get(port)\n                if nn is None:\n                    continue\n                nid = net_id(nn)\n                out.append(f'  {cid} -- {nid} [label=\"{port.name}\"];')\n        out.append(\"}\")\n        return \"\\n\".join(out)\n\n    def render_svg(self, out_path: str) -&gt; bool:\n        \"\"\"Render DOT to SVG using the 'dot' executable (Graphviz). Returns True if saved.\"\"\"\n        dot = shutil.which(\"dot\")\n        if not dot:\n            return False\n        tmp_dot = Path(out_path).with_suffix(\".dot\")\n        tmp_dot.write_text(self.to_dot(), encoding=\"utf-8\")\n        proc = subprocess.run([dot, \"-Tsvg\", str(tmp_dot), \"-o\", out_path], capture_output=True)\n        return proc.returncode == 0\n</code></pre>"},{"location":"reference/core/#cat.core.circuit.Circuit.add_directive","title":"<code>add_directive(line)</code>","text":"<p>Append a raw SPICE directive (e.g., \".model ...\", \".param ...\").</p> Source code in <code>src/cat/core/circuit.py</code> <pre><code>def add_directive(self, line: str) -&gt; Circuit:\n    \"\"\"Append a raw SPICE directive (e.g., \".model ...\", \".param ...\").\"\"\"\n    self._directives.append(line.rstrip(\"\\n\"))\n    return self\n</code></pre>"},{"location":"reference/core/#cat.core.circuit.Circuit.render_svg","title":"<code>render_svg(out_path)</code>","text":"<p>Render DOT to SVG using the 'dot' executable (Graphviz). Returns True if saved.</p> Source code in <code>src/cat/core/circuit.py</code> <pre><code>def render_svg(self, out_path: str) -&gt; bool:\n    \"\"\"Render DOT to SVG using the 'dot' executable (Graphviz). Returns True if saved.\"\"\"\n    dot = shutil.which(\"dot\")\n    if not dot:\n        return False\n    tmp_dot = Path(out_path).with_suffix(\".dot\")\n    tmp_dot.write_text(self.to_dot(), encoding=\"utf-8\")\n    proc = subprocess.run([dot, \"-Tsvg\", str(tmp_dot), \"-o\", out_path], capture_output=True)\n    return proc.returncode == 0\n</code></pre>"},{"location":"reference/core/#cat.core.circuit.Circuit.summary","title":"<code>summary()</code>","text":"<p>Return a human-friendly connectivity summary and basic lint warnings.</p> Source code in <code>src/cat/core/circuit.py</code> <pre><code>def summary(self) -&gt; str:\n    \"\"\"Return a human-friendly connectivity summary and basic lint warnings.\"\"\"\n    # Map nets to connected ports (ref.port)\n    net_to_ports: dict[str, list[str]] = {}\n    unconnected: list[str] = []\n    # Ensure we have stable net names even if build wasn't called\n    # We'll map by object identity with temporary IDs\n    temp_ids: dict[Any, int] = {}\n    next_id = 1\n\n    def name_of_net(n: Net) -&gt; str:\n        nonlocal next_id\n        if n is GND:\n            return \"0\"\n        if n.name and n.name != \"0\":\n            return n.name\n        if n not in temp_ids:\n            temp_ids[n] = next_id\n            next_id += 1\n        return f\"n{temp_ids[n]}\"\n\n    for comp in self._components:\n        for port in comp.ports:\n            key = f\"{comp.ref}.{port.name}\"\n            n = self._port_to_net.get(port)\n            if n is None:\n                unconnected.append(key)\n            else:\n                nn = name_of_net(n)\n                net_to_ports.setdefault(nn, []).append(key)\n\n    lines: list[str] = [f\"Circuit: {self.name}\"]\n    lines.append(\"Connections:\")\n    for nn, plist in sorted(net_to_ports.items()):\n        plist_sorted = \", \".join(sorted(plist))\n        lines.append(f\"  {nn}: {plist_sorted}\")\n\n    # Lint\n    warnings: list[str] = []\n    for nn, plist in net_to_ports.items():\n        if nn != \"0\" and len(plist) &lt;= 1:\n            warnings.append(f\"Net '{nn}' has degree {len(plist)} (possible floating)\")\n    if unconnected:\n        warnings.append(f\"Unconnected ports: {', '.join(sorted(unconnected))}\")\n    if warnings:\n        lines.append(\"Warnings:\")\n        for w in warnings:\n            lines.append(f\"  - {w}\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/#cat.core.circuit.Circuit.to_dot","title":"<code>to_dot()</code>","text":"<p>Export a Graphviz DOT representation (components as boxes, nets as ellipses).</p> Source code in <code>src/cat/core/circuit.py</code> <pre><code>def to_dot(self) -&gt; str:\n    \"\"\"Export a Graphviz DOT representation (components as boxes, nets as ellipses).\"\"\"\n    # Build stable names\n    self._assign_node_ids()\n    comp_ids: dict[Component, str] = {}\n    net_ids: dict[Net, str] = {}\n\n    def comp_id(c: Component) -&gt; str:\n        if c not in comp_ids:\n            comp_ids[c] = f\"comp_{c.ref}\"\n        return comp_ids[c]\n\n    def net_id(n: Net) -&gt; str:\n        if n not in net_ids:\n            if n is GND:\n                net_ids[n] = \"net_0\"\n            else:\n                name = n.name or f\"n{self._net_ids.get(n, 0)}\"\n                safe = name.replace('\"', \"'\")\n                net_ids[n] = f\"net_{safe}\"\n        return net_ids[n]\n\n    lines: list[str] = []\n    lines.append(\"graph circuit {\\n  rankdir=LR;\\n  node [fontname=Helvetica];\\n}\")\n    out: list[str] = [\"graph circuit {\", \"  rankdir=LR;\"]\n    # Net nodes\n    seen_nets: set[Net] = set()\n    for n in set(self._port_to_net.values()):\n        nid = net_id(n)\n        label = \"0\" if n is GND else (n.name or f\"n{self._net_ids.get(n, 0)}\")\n        if n is GND:\n            out.append(\n                f'  {nid} [shape=ellipse, label=\"{label}\", style=filled, fillcolor=lightgray];'\n            )\n        else:\n            out.append(f'  {nid} [shape=ellipse, label=\"{label}\"];')\n        seen_nets.add(n)\n    # Component nodes\n    for c in self._components:\n        cid = comp_id(c)\n        val = str(c.value)\n        out.append(f'  {cid} [shape=box, label=\"{type(c).__name__} {c.ref}\\\\n{val}\"];')\n    # Edges\n    for c in self._components:\n        cid = comp_id(c)\n        for port in c.ports:\n            nn = self._port_to_net.get(port)\n            if nn is None:\n                continue\n            nid = net_id(nn)\n            out.append(f'  {cid} -- {nid} [label=\"{port.name}\"];')\n    out.append(\"}\")\n    return \"\\n\".join(out)\n</code></pre>"},{"location":"reference/io/","title":"IO API","text":"<p>Placeholder for IO-related API docs.</p>"},{"location":"reference/io/#cat.io.raw_reader.Trace","title":"<code>Trace</code>  <code>dataclass</code>","text":"<p>Um tra\u00e7o: nome, unidade (quando existir) e vetor de valores (np.ndarray).</p> Source code in <code>src/cat/io/raw_reader.py</code> <pre><code>@dataclass(frozen=True)\nclass Trace:\n    \"\"\"Um tra\u00e7o: nome, unidade (quando existir) e vetor de valores (np.ndarray).\"\"\"\n\n    name: str\n    unit: str | None\n    values: NDArray[Any]\n    _complex: NDArray[Any] | None = None  # apenas AC: vetor complex\n\n    def magnitude(self) -&gt; NDArray[Any]:\n        if self._complex is not None:\n            return cast(NDArray[Any], np.abs(self._complex))\n        return cast(NDArray[Any], np.abs(self.values))\n\n    def real(self) -&gt; NDArray[Any]:\n        if self._complex is not None:\n            return self._complex.real\n        return self.values\n\n    def imag(self) -&gt; NDArray[Any]:\n        if self._complex is not None:\n            return self._complex.imag\n        return np.zeros_like(self.values, dtype=float)\n\n    def phase_deg(self) -&gt; NDArray[Any]:\n        if self._complex is not None:\n            return np.angle(self._complex, deg=True)\n        return np.zeros_like(self.values, dtype=float)\n</code></pre>"},{"location":"reference/io/#cat.io.raw_reader.TraceSet","title":"<code>TraceSet</code>","text":"<p>Conjunto de tra\u00e7os indexado por nome. O primeiro tra\u00e7o \u00e9 o eixo X (time/freq).</p> Acesso <p>ts[\"V(out)\"] -&gt; Trace ts.x -&gt; Trace (primeira coluna) ts.names -&gt; lista de nomes ts.to_dataframe() -&gt; pandas.DataFrame (se pandas instalado)</p> Source code in <code>src/cat/io/raw_reader.py</code> <pre><code>class TraceSet:\n    \"\"\"\n    Conjunto de tra\u00e7os indexado por nome. O primeiro tra\u00e7o \u00e9 o eixo X (time/freq).\n\n    Acesso:\n        ts[\"V(out)\"] -&gt; Trace\n        ts.x -&gt; Trace (primeira coluna)\n        ts.names -&gt; lista de nomes\n        ts.to_dataframe() -&gt; pandas.DataFrame (se pandas instalado)\n    \"\"\"\n\n    def __init__(self, traces: list[Trace]) -&gt; None:\n        if not traces:\n            raise ValueError(\"TraceSet requires at least one trace\")\n        self._traces = traces\n        self._by_name: dict[str, Trace] = {t.name: t for t in traces}\n\n        # valida tamanhos\n        n = len(self._traces[0].values)\n        for t in self._traces[1:]:\n            if len(t.values) != n:\n                raise ValueError(\"All traces must have same length\")\n\n    @property\n    def x(self) -&gt; Trace:\n        return self._traces[0]\n\n    @property\n    def names(self) -&gt; list[str]:\n        return [t.name for t in self._traces]\n\n    def __getitem__(self, key: str) -&gt; Trace:\n        try:\n            return self._by_name[key]\n        except KeyError as e:\n            raise KeyError(f\"Trace '{key}' not found. Available: {self.names}\") from e\n\n    def to_dataframe(self) -&gt; Any:\n        # Evita depender de stubs do pandas: import din\u00e2mico via importlib, tipado como Any\n        try:\n            pd: Any = importlib.import_module(\"pandas\")\n        except Exception as exc:  # pragma: no cover\n            raise RuntimeError(\"pandas is required for to_dataframe()\") from exc\n        data = {t.name: t.values for t in self._traces}\n        return pd.DataFrame(data)\n</code></pre>"},{"location":"reference/io/#cat.io.raw_reader.parse_ngspice_ascii_raw","title":"<code>parse_ngspice_ascii_raw(path)</code>","text":"<p>Parser robusto para NGSpice ASCII RAW.</p> <p>Retorna TraceSet onde a primeira coluna \u00e9 o eixo X (tipicamente 'time' ou 'frequency').</p> Source code in <code>src/cat/io/raw_reader.py</code> <pre><code>def parse_ngspice_ascii_raw(path: str) -&gt; TraceSet:\n    \"\"\"\n    Parser robusto para NGSpice ASCII RAW.\n\n    Retorna TraceSet onde a primeira coluna \u00e9 o eixo X (tipicamente 'time' ou 'frequency').\n    \"\"\"\n    with open(path, encoding=\"utf-8\", errors=\"ignore\") as f:\n        lines = f.read().splitlines()\n\n    meta, i0 = _parse_header(lines)\n    nvars = int(meta[\"nvars\"])\n    npoints = int(meta[\"npoints\"])\n    vars_meta, i1 = _parse_variables(lines, i0, nvars)\n    data, complex_cols = _parse_values(lines, i1, nvars, npoints)\n\n    traces: list[Trace] = []\n    for j, (name, unit) in enumerate(vars_meta):\n        traces.append(\n            Trace(\n                name=name,\n                unit=unit,\n                values=data[:, j].copy(),\n                _complex=complex_cols[j],\n            )\n        )\n    return TraceSet(traces)\n</code></pre>"},{"location":"reference/io/#cat.io.raw_reader.parse_ngspice_ascii_raw_multi","title":"<code>parse_ngspice_ascii_raw_multi(path)</code>","text":"<p>L\u00ea um arquivo ASCII com m\u00faltiplos plots (p.ex. .step nativo) e retorna uma lista de TraceSet (um por bloco).</p> Source code in <code>src/cat/io/raw_reader.py</code> <pre><code>def parse_ngspice_ascii_raw_multi(path: str) -&gt; list[TraceSet]:\n    \"\"\"\n    L\u00ea um arquivo ASCII com m\u00faltiplos plots (p.ex. .step nativo) e retorna\n    uma lista de TraceSet (um por bloco).\n    \"\"\"\n    with open(path, encoding=\"utf-8\", errors=\"ignore\") as f:\n        lines = f.read().splitlines()\n\n    i = 0\n    out: list[TraceSet] = []\n    while i &lt; len(lines):\n        # procurar in\u00edcio de um bloco (Title:/Plotname:/Variables:)\n        # Reutiliza as fun\u00e7\u00f5es privadas para cada bloco\n        # pular linhas vazias\n        while i &lt; len(lines) and not lines[i].strip():\n            i += 1\n        if i &gt;= len(lines):\n            break\n        # precisa ver se h\u00e1 um cabe\u00e7alho v\u00e1lido\n        try:\n            meta, i0 = _parse_header(lines[i:])\n            nvars = int(meta[\"nvars\"])\n            npoints = int(meta[\"npoints\"])\n            vars_meta, i1 = _parse_variables(lines[i:], i0, nvars)\n            data, complex_cols = _parse_values(lines[i:], i1, nvars, npoints)\n        except Exception:\n            # se n\u00e3o conseguiu, avan\u00e7a uma linha e tenta de novo\n            i += 1\n            continue\n\n        traces: list[Trace] = []\n        for j, (name, unit) in enumerate(vars_meta):\n            traces.append(\n                Trace(name=name, unit=unit, values=data[:, j].copy(), _complex=complex_cols[j])\n            )\n        out.append(TraceSet(traces))\n        # avan\u00e7ar: i += i1 + npoints ... mas j\u00e1 usamos slices; ent\u00e3o mova i para frente\n        # tenta achar pr\u00f3ximo 'Title:' ap\u00f3s o bloco atual\n        # heur\u00edstica simples: move i at\u00e9 encontrar pr\u00f3xima 'Title:' ou EOF\n        k = i + i1 + npoints + 4  # + margem\n        i = max(i + 1, k)\n    return out\n</code></pre>"},{"location":"reference/io/#cat.io.raw_reader.parse_ngspice_raw","title":"<code>parse_ngspice_raw(path)</code>","text":"<p>Dispatcher: se for ASCII, usa parse_ngspice_ascii_raw; se for 'Binary', tenta fallback convertendo para ASCII n\u00e3o invasivo (a depender da gera\u00e7\u00e3o do arquivo). Por ora, detecta 'Binary' e dispara erro com mensagem clara.</p> Source code in <code>src/cat/io/raw_reader.py</code> <pre><code>def parse_ngspice_raw(path: str) -&gt; TraceSet:\n    \"\"\"\n    Dispatcher: se for ASCII, usa parse_ngspice_ascii_raw; se for 'Binary', tenta\n    fallback convertendo para ASCII n\u00e3o invasivo (a depender da gera\u00e7\u00e3o do arquivo).\n    Por ora, detecta 'Binary' e dispara erro com mensagem clara.\n    \"\"\"\n    with open(path, \"rb\") as f:\n        head = f.read(256)\n    if b\"Binary:\" in head or b\"binary\" in head:\n        # Implementa\u00e7\u00e3o bin\u00e1ria completa \u00e9 extensa; orientar uso de ASCII no runner.\n        raise NotImplementedError(\n            \"Binary RAW not supported yet. Configure NGSpice to write ASCII RAW \"\n            \"(set filetype=ascii).\"\n        )\n    # ASCII\n    return parse_ngspice_ascii_raw(path)\n</code></pre>"}]}