{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyCircuitKit","text":"<p>PyCircuitKit is a modern Python toolkit for building circuits, generating SPICE netlists, and running analyses (Monte Carlo, AC, transient) with lightweight testing helpers.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Clean, typed APIs</li> <li>Pluggable SPICE runners (ngspice)</li> <li>LTspice integration (netlist import + <code>.asc</code> schematic round-trip)</li> <li>Example-driven tutorials and automated tests</li> </ul>"},{"location":"#quick-start","title":"Quick start","text":"<p>Run locally:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install -e .\n</code></pre> <p>Try the examples in the <code>examples/</code> folder after installing the package. Many examples print SPICE cards you can save as <code>.cir</code> and run with Ngspice or LTspice.</p>"},{"location":"#simulate-analog-adc-quick-note","title":"Simulate analog + ADC (quick note)","text":"<p>This repo includes an <code>AnalogMux8</code> component that emits SPICE for an 8:1 analog multiplexer and a Python <code>ADCModel</code> (in <code>src/spicelab/core/adc.py</code>) that emulates sample-and-hold, aperture/jitter and quantization. Typical workflow:</p> <ol> <li>Use components' <code>spice_card(net_of)</code> to generate a netlist (mux, sources, R/C front-end).</li> <li>Run Ngspice/LTspice transient simulation on the netlist.</li> <li>Post-process the simulated node waveform in Python using <code>ADCModel.sample_from_function</code> or <code>sample_sh</code> to obtain digital codes.</li> </ol>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Installation: <code>installation.md</code></li> <li>Getting started: <code>getting-started.md</code></li> <li>Examples: <code>examples.md</code></li> <li>Examples gallery: <code>examples-gallery.md</code></li> </ul>"},{"location":"ac-stability/","title":"AC Stability (Bode, PM/GM)","text":"<p>Compute Bode magnitude/phase and stability margins from an AC run.</p> <p></p> <p>Note: NGSpice names nodes as <code>n1</code>, <code>n2</code>, ... in the RAW file by default. Use <code>v(n1)</code> for the first node voltage (output in the RC examples).</p>"},{"location":"ac-stability/#quick-bode","title":"Quick Bode","text":"<pre><code>from spicelab.analysis import bode\n\n# Run an AC sweep and get (f, mag_db, phase_deg)\nf, mag_db, ph = bode(c, y_out=\"v(n1)\", sweep_type=\"dec\", n=201, fstart=10.0, fstop=1e6)\n</code></pre> <p>The circuit must include a small-signal AC source (e.g., <code>VA()</code> or <code>Iac</code>).</p>"},{"location":"ac-stability/#margins-and-bandwidth","title":"Margins and bandwidth","text":"<pre><code>from spicelab.analysis import ac_gain_phase, bandwidth_3db, crossover_freq_0db, phase_margin, gain_margin_db\n\nres = run_ac(c, \"dec\", 201, 10.0, 1e6)\nf, g_db, ph = ac_gain_phase(res.traces, y_out=\"v(n1)\")\n\nbw = bandwidth_3db(res.traces, y_out=\"v(n1)\")\nwc = crossover_freq_0db(res.traces, y_out=\"v(n1)\")\npm = phase_margin(res.traces, y_out=\"v(n1)\")\ngm = gain_margin_db(res.traces, y_out=\"v(n1)\")\nprint(bw, wc, pm, gm)\n</code></pre> <p>Use <code>plot_bode(ts, y)</code> to open an interactive Plotly Bode chart when a complex trace is available.</p>"},{"location":"api-reference/","title":"API reference guidance","text":"<p>This project uses <code>mkdocstrings</code> to collect API documentation from the <code>src/</code> package. The handler is configured in <code>mkdocs.yml</code> with a <code>search_path</code> that points to <code>src</code> so local imports resolve during the site build. This project uses <code>mkdocstrings</code> to collect API documentation from the root package (<code>spicelab</code>). The handler is configured in <code>mkdocs.yml</code> and searches the repository root so local imports resolve during the site build.</p> <p>How to add a module to the API reference</p> <ol> <li>Add a markdown file under <code>docs/reference/</code> and include the <code>::: path.to.module</code>    directive where you want the auto-generated docstring content to appear.</li> </ol> <p>Example: <code>docs/reference/analysis.md</code></p> <pre><code>::: spicelab.analysis\n</code></pre> <ol> <li> <p>Run <code>mkdocs build</code> locally to generate the site and verify that    mkdocstrings finds the module. If mkdocstrings fails to import the module,    ensure your virtualenv has the package installed (<code>pip install -e .</code>) and    that <code>mkdocs</code> is executed from the repository root.</p> </li> <li> <p>Keep exported API stable: prefer documenting public top-level methods and    classes from the <code>spicelab.*</code> namespace. Avoid heavy implementation details; use    examples for usage patterns.</p> </li> </ol> <p>Troubleshooting imports</p> <p>environment used for the docs build (dev-requirements.txt).</p> <p>Packaging tips</p> <p>examples you intend to show in the API docs. This keeps local builds   reproducible.   environment that includes dev/test dependencies so mkdocstrings can import   modules without errors.</p>"},{"location":"cli-ci/","title":"CLI and CI guide","text":"<p>This page documents the common CLI flags supported by examples and recommended patterns for running examples in CI.</p>"},{"location":"cli-ci/#common-flags","title":"Common flags","text":"<ul> <li><code>--outdir PATH</code> \u2014 write all generated artifacts (plots, model files,   reports) to PATH. Examples default to the current working directory. For CI   use a temporary directory (see pattern below).</li> <li><code>--real-run</code> \u2014 when present, the example invokes the real simulator   (<code>ngspice</code>) instead of the internal fake-runner used for fast CI runs.</li> <li><code>--n</code> or <code>--trials</code> \u2014 number of Monte Carlo trials (used by   <code>monte_carlo_demo.py</code>).</li> </ul>"},{"location":"cli-ci/#ci-recommendations","title":"CI recommendations","text":"<ol> <li>Use a temporary output directory and pass it with <code>--outdir</code> so test artifacts don't leak into the repo. Example pytest pattern:</li> </ol> <pre><code>def test_example_smoke(tmp_path):\n    outdir = tmp_path / \"example_out\"\n    outdir.mkdir()\n    subprocess.run([\"python\", \"examples/monte_carlo_demo.py\", \"--outdir\", str(outdir)], check=True)\n    assert any(outdir.iterdir())\n</code></pre> <ol> <li> <p>Prefer the fake-runner in automated tests. The fake-runner provides a deterministic, fast output that is sufficient for smoke tests and visualization pipelines.</p> </li> <li> <p>Run heavier simulations with <code>--real-run</code> only in dedicated integration tests or developer runs where <code>ngspice</code> is available.</p> </li> <li> <p>Upload the <code>--outdir</code> contents as CI artifacts when you need to inspect plots or the HTML report.</p> </li> </ol>"},{"location":"cli-ci/#how-to-enable-the-fake-runner-in-tests","title":"How to enable the fake-runner in tests","text":"<p>Examples are written to select the fake-runner by default when the real simulator is unavailable. If you need to force the fake-runner from code, most examples accept an entrypoint to pass the runner object directly. See the example module docstrings for details.</p>"},{"location":"components-library/","title":"Component Library","text":"<p>CAT provides a lightweight registry that lets you register custom component factories and instantiate them later by name. This makes it easy to distribute manufacturer-specific parts (for example, a diode with a recommended <code>.model</code> card) or project-specific helpers.</p> <pre><code>from spicelab.library import create_component, register_component\nfrom spicelab.core.components import Resistor\n\nregister_component(\"custom.res\", lambda ref, value: Resistor(ref, value))\npart = create_component(\"custom.res\", ref=\"R1\", value=\"4k7\")\n</code></pre>"},{"location":"components-library/#built-in-catalog","title":"Built-in catalog","text":"<p>The <code>spicelab.library</code> package ships with a starter catalog. For example:</p> <pre><code>from spicelab.library import create_component, get_component_spec\n\nd = create_component(\"diode.1n4007\", ref=\"D1\")\nspec = get_component_spec(\"diode.1n4007\")\nprint(spec.metadata[\"model_card\"])  # recommended .model statement\n</code></pre> <p>The catalog is organised by category. You can discover available entries via <code>list_components()</code> or <code>list_components(category=\"diode\")</code>.</p>"},{"location":"components-library/#creating-reusable-parts","title":"Creating reusable parts","text":"<p>A registered factory can accept any positional/keyword arguments. Metadata can be attached during registration to capture links, model cards, etc.</p> <pre><code>from spicelab.core.components import Diode\nfrom spicelab.library import register_component\n\nregister_component(\n    \"diode.bat54\",\n    lambda ref, model=\"DBAT54\": Diode(ref, model),\n    category=\"diode\",\n    metadata={\"datasheet\": \"https://www.onsemi.com/pdf/datasheet/bat54-d.pdf\"},\n)\n</code></pre> <p>Factories can also return subclasses of <code>Component</code>, enabling more elaborate behaviour.</p> <p>Remember to unregister temporary factories used inside tests by calling <code>unregister_component(name)</code>.</p> <p>Many entries expose a <code>model_card</code> metadata field containing a ready-to-use <code>.model</code> or <code>.include</code> statement. For example::</p> <pre><code>from spicelab.library import get_component_spec\nspec = get_component_spec('mosfet.bss138')\ncircuit.add_directive(spec.metadata['model_card'])\n</code></pre> <p>You can discover parts programmatically using <code>search_components</code>::</p> <pre><code>from spicelab.library import search_components\nmosfets = search_components(metadata={'polarity': 'n-channel'})\n</code></pre> <p>This supports filtering by name substring, category, metadata key/value pairs, and custom predicates.</p> <p>To inject the recommended SPICE directives into a circuit once::</p> <pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.library import get_component_spec, apply_metadata_to_circuit\n\ncircuit = Circuit('demo')\nspec = get_component_spec('diode.1n4007')\napply_metadata_to_circuit(circuit, spec)  # adds .model/.include only if absent\n</code></pre>"},{"location":"components-library/#importing-external-catalogs","title":"Importing external catalogs","text":"<p>You can register many parts at once using the import helpers::</p> <pre><code>from spicelab.library.importers import import_catalog_from_json\nimport_catalog_from_json('my_components.json')\n</code></pre> <p>The JSON file should contain a list of entries with <code>name</code>, <code>factory</code> (or a custom <code>factory_builder</code>), optional <code>category</code>, and metadata fields. Similar helpers exist for CSV data (<code>import_catalog_from_csv</code>) and in-memory structures (<code>import_catalog_from_mapping</code>).</p>"},{"location":"components-quickstart/","title":"Components Quickstart","text":""},{"location":"components-quickstart/#components-quickstart","title":"Components Quickstart","text":"<p>A compact cheat\u2011sheet for the main components exposed by PyCircuitKit. The table shows the Python class, an optional helper function, the SPICE card that is generated, port names, and relevant notes.</p> <p>Import helpers used below:</p> <pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.net import GND, Net\nfrom spicelab.core.components import *\n</code></pre> Python (Class) Helper SPICE Card (shape) Ports Notes <code>Resistor</code> <code>R(value)</code> <code>Rref a b value</code> <code>a, b</code> Value accepts suffixes (<code>\"1k\"</code>, <code>\"100n\"</code>). <code>Capacitor</code> <code>C(value)</code> <code>Cref a b value</code> <code>a, b</code> <code>Inductor</code> <code>L(value)</code> <code>Lref a b value</code> <code>a, b</code> <code>Vdc</code> <code>V(value)</code> <code>Vref p n value</code> <code>p, n</code> DC source. <code>Vac</code> <code>VA(ac_mag, ac_phase=0)</code> <code>Vref p n AC mag [phase]</code> <code>p, n</code> Small\u2011signal AC. <code>Vpulse</code> <code>VP(v1, v2, td, tr, tf, pw, per)</code> <code>Vref p n PULSE(...)</code> <code>p, n</code> <code>Vsin</code> \u2014 <code>Vref p n SIN(vdc vac freq td theta)</code> <code>p, n</code> Sine. <code>Vpwl</code> \u2014 <code>Vref p n PWL(&lt;args_raw&gt;)</code> <code>p, n</code> Raw args string. <code>Idc</code> <code>I(value)</code> <code>Iref p n value</code> <code>p, n</code> DC current source. <code>Iac</code> <code>IA(ac_mag, ac_phase=0)</code> <code>Iref p n AC mag [phase]</code> <code>p, n</code> Small\u2011signal AC. <code>Ipulse</code> <code>IP(i1, i2, td, tr, tf, pw, per)</code> <code>Iref p n PULSE(...)</code> <code>p, n</code> <code>Isin</code> \u2014 <code>Iref p n SIN(idc iac freq td theta)</code> <code>p, n</code> <code>Ipwl</code> \u2014 <code>Iref p n PWL(&lt;args_raw&gt;)</code> <code>p, n</code> <code>VCVS</code> <code>E(gain)</code> <code>Eref p n cp cn gain</code> <code>p, n, cp, cn</code> Voltage\u2011controlled voltage src. <code>VCCS</code> <code>G(gm)</code> <code>Gref p n cp cn gm</code> <code>p, n, cp, cn</code> Voltage\u2011controlled current src. <code>CCCS</code> <code>F(ctrl_vsrc, gain)</code> <code>Fref p n Vsrc gain</code> <code>p, n</code> Current\u2011controlled current src. <code>CCVS</code> <code>H(ctrl_vsrc, r)</code> <code>Href p n Vsrc r</code> <code>p, n</code> Current\u2011controlled voltage src. <code>Diode</code> <code>D(model)</code> <code>Dref a c model</code> <code>a, c</code> Requires matching <code>.model</code> directive. <code>VSwitch</code> <code>SW(model)</code> <code>Sref p n cp cn model</code> <code>p, n, cp, cn</code> Needs <code>.model &lt;name&gt; SW(...)</code>. <code>ISwitch</code> <code>SWI(ctrl_vsrc, model)</code> <code>Wref p n Vsrc model</code> <code>p, n</code> Current\u2011controlled switch. <code>OpAmpIdeal</code> <code>OA(gain=1e6)</code> <code>Eref out 0 inp inn gain</code> <code>inp, inn, out</code> 3\u2011pin ideal OA, VCVS\u2011based. <code>AnalogMux8</code> <code>MUX8(r_series, sel)</code> \u2014 <code>in, out0..out7, [en0..en7]</code> Emits Rs (static <code>sel</code>) or <code>S...</code> + R when <code>enable_ports=True</code>. <p>Notes</p> <ul> <li>Numeric strings accept engineering suffixes (k, m, u/\u00b5, n, p, g, t, <code>meg</code>).</li> <li>Controlled sources <code>F</code>/<code>H</code> use a voltage source name (<code>V1</code> etc.) as current sensor.</li> <li><code>AnalogMux8</code> parameters: <code>r_series</code>, <code>sel</code> (0..7), <code>off_resistance</code>, <code>enable_ports</code>,   <code>emit_model</code>, <code>sw_model</code>. When using switches, add a suitable <code>.model</code> line for the   <code>SW</code> element (or pass <code>emit_model=True</code>).</li> </ul>"},{"location":"components/","title":"Components","text":""},{"location":"components/#components-guide","title":"Components Guide","text":"<p>This page shows how to instantiate and use the available components in PyCircuitKit, with small runnable snippets. All examples use the same pattern:</p> <ul> <li>Create a <code>Circuit</code> and add components</li> <li>Connect ports to named nets (or <code>GND</code>)</li> <li>Optionally run an analysis (OP/TRAN/AC/DC) to verify behavior</li> </ul> <p>Minimal scaffolding used below:</p> <pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.net import GND, Net\nfrom spicelab.core.components import *  # convenient in examples\nfrom spicelab.analysis import OP, TRAN, AC, DC\n</code></pre> <p>Tip: Run examples from docs by copying blocks into a file and using <code>python your_file.py</code> (after <code>pip install -e .</code>) or <code>PYTHONPATH=. python your_file.py</code> from repo root.</p>"},{"location":"components/#passive-components","title":"Passive Components","text":"<ul> <li><code>Resistor(ref, value)</code> \u2014 two-terminal R. Value accepts numeric or suffixed string (e.g. \"1k\").</li> <li><code>Capacitor(ref, value)</code> \u2014 two-terminal C.</li> <li><code>Inductor(ref, value)</code> \u2014 two-terminal L.</li> </ul> <pre><code>c = Circuit(\"rc\")\nvin = Net(\"vin\"); vout = Net(\"vout\")\nV1 = Vdc(\"1\", 5.0)\nR1 = Resistor(\"1\", \"1k\")\nC1 = Capacitor(\"1\", \"100n\")\nc.add(V1, R1, C1)\nc.connect(V1.ports[0], vin); c.connect(V1.ports[1], GND)\nc.connect(R1.ports[0], vin); c.connect(R1.ports[1], vout)\nc.connect(C1.ports[0], vout); c.connect(C1.ports[1], GND)\nres = OP().run(c)\nprint(\"V(vout)=\", float(res.traces[\"v(vout)\"].values[-1]))\n</code></pre>"},{"location":"components/#independent-sources-voltagecurrent","title":"Independent Sources (Voltage/Current)","text":"<ul> <li>DC: <code>Vdc</code>, <code>Idc</code></li> <li>AC (small-signal): <code>Vac(ac_mag=..., ac_phase=...)</code>, <code>Iac(...)</code></li> <li>PULSE: <code>Vpulse(v1, v2, td, tr, tf, pw, per)</code>, <code>Ipulse(i1, i2, td, tr, tf, pw, per)</code></li> <li>SIN: <code>Vsin(vdc, vac, freq, td, theta)</code>, <code>Isin(...)</code></li> <li>PWL: <code>Vpwl(args_raw)</code>, <code>Ipwl(args_raw)</code> where <code>args_raw</code> is the inside of PWL(...)</li> </ul> <p>Helpers with auto-references are available: <code>V</code>, <code>VA</code>, <code>VP</code>, <code>I</code>, <code>IA</code>, <code>IP</code>.</p> <pre><code># Transient: step 0-&gt;1V into RC\nc = Circuit(\"tran_step\")\nvin = Net(\"vin\"); vout = Net(\"vout\")\nVp = Vpulse(\"1\", 0.0, 1.0, 0.0, 1e-6, 1e-6, 1e-3, 2e-3)\nR = Resistor(\"1\", 1000.0); C = Capacitor(\"1\", 1e-6)\nc.add(Vp, R, C)\nc.connect(Vp.ports[0], vin); c.connect(Vp.ports[1], GND)\nc.connect(R.ports[0], vin); c.connect(R.ports[1], vout)\nc.connect(C.ports[0], vout); c.connect(C.ports[1], GND)\nres = TRAN(\"0.1ms\", \"5ms\").run(c)\nprint(\"last V(vout)=\", float(res.traces[\"v(vout)\"].values[-1]))\n</code></pre>"},{"location":"components/#controlled-sources-egfh","title":"Controlled Sources (E/G/F/H)","text":"<ul> <li><code>VCVS(ref, gain)</code> \u2192 E: voltage-controlled voltage source</li> <li><code>VCCS(ref, gm)</code> \u2192 G: voltage-controlled current source</li> <li><code>CCCS(ref, ctrl_vsrc, gain)</code> \u2192 F: current-controlled current source (uses a voltage source name as sensor)</li> <li><code>CCVS(ref, ctrl_vsrc, r)</code> \u2192 H: current-controlled voltage source</li> </ul> <pre><code># VCVS gain=2 driving 1k load\nc = Circuit(\"vcvs\")\nvin = Net(\"vin\"); vout = Net(\"vout\")\nV1 = Vdc(\"1\", 1.0); E1 = VCVS(\"1\", 2.0); RL = Resistor(\"L\", 1000.0)\nc.add(V1, E1, RL)\nc.connect(V1.ports[0], vin); c.connect(V1.ports[1], GND)\nc.connect(E1.ports[2], vin); c.connect(E1.ports[3], GND)  # control\nc.connect(E1.ports[0], vout); c.connect(E1.ports[1], GND)  # output\nc.connect(RL.ports[0], vout); c.connect(RL.ports[1], GND)\nprint(float(OP().run(c).traces[\"v(vout)\"].values[-1]))  # \u2248 2.0 V\n</code></pre>"},{"location":"components/#diodes-and-switches","title":"Diodes and Switches","text":"<ul> <li><code>Diode(ref, model)</code> and add a matching <code>.model</code> directive to the circuit.</li> <li>Voltage/Current-controlled switches: <code>VSwitch</code>, <code>ISwitch</code> (require <code>.model &lt;name&gt; SW(...)</code>).</li> </ul> <pre><code># Diode biased from 1V through 1k\nc = Circuit(\"d_fwd\")\nn1 = Net(\"n1\")\nV = Vdc(\"1\", 1.0); R = Resistor(\"1\", 1000.0); D = Diode(\"1\", \"D1\")\nc.add_directive(\".model D1 D(Is=1e-14)\")\nc.add(V, R, D)\nc.connect(V.ports[0], R.ports[0]); c.connect(R.ports[1], n1)\nc.connect(D.ports[0], n1); c.connect(D.ports[1], GND)\nc.connect(V.ports[1], GND)\nprint(float(OP().run(c).traces[\"v(n1)\"].values[-1]))\n</code></pre>"},{"location":"components/#ideal-op-amp","title":"Ideal Op-Amp","text":"<ul> <li><code>OpAmpIdeal(ref, gain)</code> or helper <code>OA(gain)</code>; three ports <code>(inp, inn, out)</code>, modeled as VCVS.</li> </ul> <pre><code># Unity-gain buffer\nc = Circuit(\"oa_buf\")\nvin = Net(\"vin\"); vout = Net(\"vout\")\nV = Vdc(\"1\", 1.0); u = OpAmpIdeal(\"1\", 1e6)\nc.add(V, u)\nc.connect(V.ports[0], vin); c.connect(V.ports[1], GND)\nc.connect(u.ports[0], vin); c.connect(u.ports[2], vout); c.connect(u.ports[1], vout)\nprint(float(OP().run(c).traces[\"v(vout)\"].values[-1]))  # \u2248 1.0 V\n</code></pre>"},{"location":"components/#analog-multiplexer-1-to-8","title":"Analog Multiplexer (1-to-8)","text":"<p>Use <code>AnalogMux8</code> to connect a single input to one of eight outputs.</p> <ul> <li>Static selection: <code>sel=N</code> chooses <code>outN</code> with series resistance <code>r_series</code> (others at <code>off_resistance</code>).</li> <li>Dynamic enable ports: <code>enable_ports=True</code> exposes <code>en0..en7</code> and emits <code>S...</code> elements; add a <code>.model</code> for the switch (or <code>emit_model=True</code>).</li> </ul> <pre><code>from spicelab.core.components import AnalogMux8\nmux = AnalogMux8(ref=\"MU1\", r_series=100, sel=4)\nprint(mux.spice_card(lambda p: p.name))\n</code></pre>"},{"location":"components/#running-analyses","title":"Running Analyses","text":"<pre><code># OP (DC operating point)\nres = OP().run(c)\n# TRAN (time-domain)\nres = TRAN(\"1us\", \"1ms\").run(c)\n# AC (small-signal)\nres = AC(\"dec\", 20, 10.0, 1e6).run(c)\n# DC sweep\nres = DC(\"1\", 0.0, 5.0, 0.1).run(c)\n</code></pre>"},{"location":"components/#notes","title":"Notes","text":"<ul> <li>Ensure <code>ngspice</code> is installed and available in PATH.</li> <li>Numeric strings with suffixes are accepted (e.g. <code>\"1k\"</code>, <code>\"100n\"</code>). See <code>spicelab.utils.units</code>.</li> <li>Controlled sources <code>F/H</code> require the name of a (dummy) voltage source for current sensing.</li> </ul>"},{"location":"concepts/","title":"Core Concepts","text":"<ul> <li>Ports: typed terminals on components (positive/negative/node).</li> <li>Nets: logical nodes (use <code>GND</code> for ground). A <code>Net</code> can be named for readability.</li> <li>Components: objects with <code>ports</code> and a <code>spice_card(net_of)</code> method.</li> <li>Circuit: container that owns components, connections, and optional SPICE directives.</li> </ul>"},{"location":"concepts/#wiring-rules","title":"Wiring rules","text":"<ul> <li>Connect <code>Port</code> to <code>Net</code>, or <code>Port</code> to <code>Port</code> (auto-creates a shared Net).</li> <li>All ports must be connected before building the netlist.</li> <li><code>GND</code> is reserved (node \"0\").</li> </ul>"},{"location":"concepts/#minimal-rc-example","title":"Minimal RC example","text":"<pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import Vdc, Resistor, Capacitor\nfrom spicelab.core.net import GND\n\nc = Circuit(\"rc\")\nV1, R1, C1 = Vdc(\"1\", 5.0), Resistor(\"1\", \"1k\"), Capacitor(\"1\", \"100n\")\nc.add(V1, R1, C1)\nc.connect(V1.ports[0], R1.ports[0])  # vin\nc.connect(R1.ports[1], C1.ports[0])  # vout\nc.connect(V1.ports[1], GND)\nc.connect(C1.ports[1], GND)\n\nprint(c.build_netlist())\n</code></pre>"},{"location":"concepts/#directives","title":"Directives","text":"<p>Use <code>circuit.add_directive(\".model ...\")</code> or <code>.param</code>, <code>.include</code>, etc., to embed raw SPICE lines.</p>"},{"location":"cookbook/","title":"Cookbook","text":"<p>Short, copy-paste recipes for common tasks.</p>"},{"location":"cookbook/#3-db-bandwidth","title":"\u22123 dB bandwidth","text":"<pre><code>from spicelab.analysis import bandwidth_3db\nbw = bandwidth_3db(res.traces, y_out=\"v(n1)\")\n</code></pre>"},{"location":"cookbook/#0-db-crossover-and-margins","title":"0 dB crossover and margins","text":"<pre><code>from spicelab.analysis import crossover_freq_0db, phase_margin, gain_margin_db\nwc = crossover_freq_0db(res.traces, y_out=\"v(n1)\")\npm = phase_margin(res.traces, y_out=\"v(n1)\")\ngm = gain_margin_db(res.traces, y_out=\"v(n1)\")\n</code></pre>"},{"location":"cookbook/#overshoot-and-settling-time","title":"Overshoot and settling time","text":"<pre><code>from spicelab.analysis import overshoot_pct, settling_time\nov = overshoot_pct(res.traces, \"v(n1)\")  # %\nst = settling_time(res.traces, \"v(n1)\")\n</code></pre>"},{"location":"cookbook/#interpolate-at-a-given-time-per-run","title":"Interpolate at a given time (per run)","text":"<pre><code>import numpy as np\n\ndef sample_at(ts, name: str, t: float) -&gt; float:\n    t_arr = ts[\"time\"].values\n    y_arr = ts[name].values\n    return float(np.interp(t, t_arr, y_arr))\n</code></pre>"},{"location":"cookbook/#stack-multiple-runs-into-a-dataframe","title":"Stack multiple runs into a DataFrame","text":"<pre><code>from spicelab.analysis import stack_runs_to_df\n# runs: list[AnalysisResult]\ndf = stack_runs_to_df(runs, y=[\"v(n1)\"], with_x=True)\n</code></pre>"},{"location":"device-models/","title":"Device Models","text":""},{"location":"device-models/#device-models-and-model-directives","title":"Device Models and <code>.model</code> Directives","text":"<p>Some components in PyCircuitKit rely on SPICE device models defined via <code>.model</code> lines in the netlist. This page shows how to add models and wire typical circuits using the high\u2011level API.</p> <p>Key points:</p> <ul> <li>Use <code>Circuit.add_directive(line)</code> to append raw SPICE directives.</li> <li>Diodes must reference a named model (e.g. <code>D1</code> \u2192 <code>.model D1 D(...)</code>).</li> <li>Voltage/Current\u2011controlled switches (<code>VSwitch</code>, <code>ISwitch</code>) require a   <code>.model &lt;name&gt; SW(...)</code> with thresholds and on/off resistances.</li> <li>Controlled sources <code>F</code>/<code>H</code> use a named voltage source as current sensor   (no <code>.model</code>, but a topology note).</li> </ul>"},{"location":"device-models/#adding-a-diode-model","title":"Adding a diode model","text":"<pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import Vdc, Resistor, Diode\nfrom spicelab.core.net import GND, Net\nfrom spicelab.analysis import OP\n\nc = Circuit(\"d_fwd\")\nn1 = Net(\"n1\")\nV = Vdc(\"1\", 1.0)\nR = Resistor(\"1\", 1000.0)\nD = Diode(\"1\", \"D1\")  # references model D1\n\n# Add a diode model (Shockley params shown as an example)\nc.add_directive(\".model D1 D(Is=1e-14 N=1.9 Rs=5 Cjo=2p)\")\n\nc.add(V, R, D)\nc.connect(V.ports[0], R.ports[0])\nc.connect(R.ports[1], n1)\nc.connect(D.ports[0], n1)  # anode\nc.connect(D.ports[1], GND)  # cathode\nc.connect(V.ports[1], GND)\n\nres = OP().run(c)\nprint(\"V(n1)=\", float(res.traces[\"v(n1)\"].values[-1]))\n</code></pre> <p>Typical parameters for the SPICE diode (<code>D</code>) model include <code>Is</code>, <code>N</code>, <code>Rs</code>, <code>Cjo</code>, <code>Bv</code>, etc. Choose values appropriate to your target device.</p>"},{"location":"device-models/#voltagecontrolled-switch-vswitch","title":"Voltage\u2011controlled switch (<code>VSwitch</code>)","text":"<pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import Vdc, Vpulse, VSwitch, Resistor\nfrom spicelab.core.net import GND, Net\nfrom spicelab.analysis import TRAN\n\nc = Circuit(\"vswitch_demo\")\nvin = Net(\"vin\")\nvout = Net(\"vout\")\nen = Net(\"en\")\n\n# Control signal: 0\u21921 V pulse\nEN = Vpulse(\"en\", 0.0, 1.0, 0.0, 1e-6, 1e-6, 1e-3, 2e-3)\nV1 = Vdc(\"1\", 5.0)\nS1 = VSwitch(\"1\", model=\"SW1\")\nRL = Resistor(\"L\", 1000.0)\n\n# Recommended switch model (tune as needed)\nc.add_directive(\".model SW1 SW(RON=10 ROFF=1e9 Vt=0.5 VH=0.1)\")\n\nc.add(EN, V1, S1, RL)\n\n# Source side\nc.connect(V1.ports[0], vin)\nc.connect(V1.ports[1], GND)\n\n# Switch: p\u2192vin, n\u2192vout, control cp\u2192en, cn\u2192GND (active high)\nc.connect(S1.ports[0], vin)   # p\nc.connect(S1.ports[1], vout)  # n\nc.connect(S1.ports[2], en)    # cp\nc.connect(S1.ports[3], GND)   # cn\n\n# Load\nc.connect(RL.ports[0], vout)\nc.connect(RL.ports[1], GND)\n\n# Control signal wiring\nc.connect(EN.ports[0], en)\nc.connect(EN.ports[1], GND)\n\nres = TRAN(\"0.1ms\", \"5ms\").run(c)\nprint(\"final V(vout)=\", float(res.traces[\"v(vout)\"].values[-1]))\n</code></pre> <p>Notes for switches:</p> <ul> <li>The switch turns on when <code>(V(cp) \u2212 V(cn)) &gt; Vt</code>. <code>VH</code> sets hysteresis.</li> <li>Choose <code>RON</code> and <code>ROFF</code> appropriate to your application.</li> <li>For current\u2011controlled switches (<code>ISwitch</code>), the control is the current   through a named voltage source <code>Vref</code> (current sensor) provided via the   <code>ctrl_vsrc</code> argument.</li> </ul>"},{"location":"device-models/#currentcontrolled-elements-fh-and-sensors","title":"Current\u2011controlled elements (<code>F</code>/<code>H</code>) and sensors","text":"<p><code>CCCS</code> (<code>F</code>) and <code>CCVS</code> (<code>H</code>) measure the current through an existing voltage source. A common pattern is to insert a 0 V source as sensor:</p> <pre><code>from spicelab.core.components import Vdc, Resistor, CCCS\n\n# Sensor source at the node of interest\nVSENS = Vdc(\"S\", 0.0)\nF1 = CCCS(\"1\", ctrl_vsrc=\"S\", gain=2.0)  # 2\u00d7 current mirror\n\n# Wire VSENS in series with the branch you want to sense\n# Then connect F1.p/n to the output branch where mirrored current flows.\n</code></pre> <p>This pattern avoids modifying the DC operating point (0 V across the sensor) while providing a reference for <code>F</code>/<code>H</code> controlled elements.</p>"},{"location":"examples-gallery/","title":"Examples Gallery","text":"<p>Curated outputs from runnable examples. Click images or links to explore.</p>"},{"location":"examples-gallery/#rc-bode-ac","title":"RC Bode (AC)","text":"<ul> <li>Guide: AC Stability</li> <li>Script: <code>examples/ac_bode.py</code></li> </ul>"},{"location":"examples-gallery/#op-amp-closed-loop-bode","title":"Op-Amp Closed-Loop Bode","text":"<ul> <li>Guide: Op-Amp Stability</li> <li>Script: <code>examples/opamp_stability.py</code></li> </ul>"},{"location":"examples-gallery/#step-grid-rc-step-vs-r","title":"STEP Grid (RC step vs R)","text":"<ul> <li>Guide: Sweeps and .STEP</li> <li>Script: <code>examples/step_sweep_fig.py</code></li> </ul>"},{"location":"examples-gallery/#monte-carlo-histogram","title":"Monte Carlo (histogram)","text":"<ul> <li>Guide: Monte Carlo</li> <li>Script: <code>examples/monte_carlo_fig.py</code></li> </ul>"},{"location":"examples-usage/","title":"Examples Usage","text":"<p>This page highlights a few runnable examples and what they demonstrate.</p>"},{"location":"examples-usage/#getting-started-tutorial","title":"Getting started (tutorial)","text":"<ul> <li><code>examples/getting_started.py</code>: a step-by-step tutorial that builds an RC circuit,   runs AC, DC and TRAN analyses, and saves plots. Run with:</li> </ul> <pre><code>cd examples\nuv run --active python getting_started.py\n</code></pre>"},{"location":"examples-usage/#monte-carlo-analysis","title":"Monte Carlo analysis","text":"<ul> <li><code>examples/monte_carlo_demo.py</code>: demonstrates running a Monte Carlo using a   configurable runner. By default it uses a fast fake-runner for demos and CI.   To run the example and save plots and an HTML report:</li> </ul> <pre><code>cd examples\nuv run --active python monte_carlo_demo.py --n 50 --outdir ./mc_out\n</code></pre>"},{"location":"examples-usage/#register-and-metadata","title":"Register and metadata","text":"<ul> <li><code>examples/register_and_metadata.py</code>: shows how to register a custom component   with metadata that includes <code>.include</code> or <code>.model</code> directives, how to apply   the metadata to a <code>Circuit</code>, and run a small operating-point analysis.</li> </ul> <pre><code>cd examples\nuv run --active python register_and_metadata.py --outdir ./artifacts\n</code></pre>"},{"location":"examples-usage/#more-examples","title":"More examples","text":"<p>See the <code>examples/</code> directory for additional demos: AC Bode plots, DC sweeps, LTSpice roundtrip helpers, op-amp stability checks, and more.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page describes the runnable examples included in the <code>examples/</code> folder and shows common CLI flags used by many scripts.</p>"},{"location":"examples/#overview","title":"Overview","text":"<p>The repository includes a set of examples that demonstrate typical workflows. Each example is a self-contained Python script that accepts optional CLI flags documented below.</p> <ul> <li><code>getting_started.py</code> \u2014 step-by-step tutorial: build a circuit and run AC,   DC and transient analyses.</li> <li><code>monte_carlo_demo.py</code> \u2014 Monte Carlo sweep, computes metrics and writes an   HTML report. Supports a fake-runner for CI and a real-run option with   <code>--real-run</code>.</li> <li><code>register_and_metadata.py</code> \u2014 shows how to register custom components and   attach metadata to them; writes a small models file and runs an OP analysis   to demonstrate the model usage.</li> <li><code>plotly_viz_demo.py</code> \u2014 demonstrates the Plotly-based visualization helpers   (install the <code>viz</code> extra and inspect the generated HTML dashboards).</li> </ul>"},{"location":"examples/#common-cli-flags","title":"Common CLI flags","text":"<p>Most examples accept these optional flags (use <code>-h</code> to see them in each script):</p> <ul> <li><code>--outdir PATH</code> \u2014 write plots, model files and reports to PATH (defaults to   the current working directory). Use a temporary directory in CI to avoid   polluting the repo.</li> <li><code>--real-run</code> \u2014 when present, the script will attempt to call the real   simulator (<code>ngspice</code>) instead of using the fast fake-runner. Omit this in   CI if ngspice is not available.</li> </ul>"},{"location":"examples/#fake-runner-vs-real-run","title":"Fake-runner vs real-run","text":"<p>The examples are written to accept either a \"fake\" runner (fast, deterministic for CI) or to invoke the real external simulator. Prefer the fake-runner in unit tests and CI. When debugging actual simulator behavior, run with <code>--real-run</code>.</p>"},{"location":"examples/#examples_1","title":"Examples","text":"<p>This project ships runnable examples in <code>examples/</code>:</p> <ul> <li><code>rc_tran.py</code> \u2014 transient of an RC low-pass</li> <li><code>ac_bode.py</code> \u2014 RC Bode magnitude/phase plot</li> <li><code>dc_sweep.py</code> \u2014 DC sweep example</li> <li><code>step_sweep_grid.py</code> \u2014 Python grid over parameters + DataFrame</li> <li><code>monte_carlo_rc.py</code> \u2014 Monte Carlo with metrics and plots</li> <li><code>opamp_closed_loop.py</code> \u2014 simple op-amp closed-loop wiring</li> <li><code>opamp_stability.py</code> \u2014 op-amp closed-loop Bode and margins</li> <li><code>pt1000_mc.py</code> \u2014 PT1000 front-end Monte Carlo (temp error histogram)</li> <li><code>rc_highpass.py</code> \u2014 RC highpass netlist builder</li> <li><code>import_ltspice_and_run.py</code> \u2014 import LTspice netlist and run</li> <li><code>ltspice_schematic_roundtrip.py</code> \u2014 export/import <code>.asc</code> schematics using <code>spicelab.io.ltspice_asc</code></li> <li><code>analog_mux_demo.py</code> \u2014 example showing AnalogMux8 netlist and DOT diagram</li> </ul> <p>Run them as modules:</p> <pre><code>python -m examples.rc_tran\npython -m examples.ac_bode\npython -m examples.step_sweep_grid\npython -m examples.monte_carlo_rc\n</code></pre> <p>See the <code>examples/</code> folder for details and more scripts.</p>"},{"location":"examples/#analog-multiplexer-example","title":"Analog multiplexer example","text":"<p>The repository includes an <code>AnalogMux8</code> component (1-to-8 analog multiplexer). See <code>examples/analog_mux_demo.py</code> for a runnable demonstration that prints the generated netlist and emits a Graphviz DOT string for quick visual inspection.</p> <p>Notes: - The component supports static selection via the <code>sel</code> parameter or dynamic     control by enabling <code>enable_ports=True</code> which exposes <code>en0..en7</code> control     pins and emits <code>S...</code> switches in the netlist. If <code>emit_model=True</code> the     example will include a recommended <code>.model</code> line for the switches. - Default series resistance <code>r_series</code> is 100 (ohms). Off-resistance is <code>1G</code>.</p>"},{"location":"examples/#run-the-demo","title":"Run the demo","text":"<p>To run the example locally (from the project root):</p> <pre><code>python examples/analog_mux_demo.py\n</code></pre> <p>This prints the generated SPICE card and a DOT string which you can render with Graphviz if available.</p>"},{"location":"examples/#quick-snippet","title":"Quick snippet","text":"<pre><code>from spicelab.core.components import AnalogMux8\n\nmux = AnalogMux8(ref=\"MU1\", r_series=100, sel=4)\nprint(mux.spice_card(lambda p: p.name))\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#getting-started","title":"Getting started","text":"<p>This quickstart guides a new user through installation, running a simple example, and best practices for CI-friendly execution. It links to example pages and the API reference.</p>"},{"location":"getting-started/#1-create-an-environment-and-install","title":"1) Create an environment and install","text":"<p>Use an isolated environment. Below is an example using the repository's helper <code>uv</code> (short for uenv). Replace it with <code>python -m venv</code> or <code>conda</code> if you prefer.</p> <pre><code># from the repository root\nuv run --active pip install -e .\nuv run --active pip install -r dev-requirements.txt\n</code></pre> <p>The development requirements will pull in test and docs dependencies used for the examples and local site builds.</p>"},{"location":"getting-started/#2-run-the-quick-example","title":"2) Run the quick example","text":"<p>The <code>examples/getting_started.py</code> script walks through building a small RC circuit and running AC, DC and transient analyses. To run it and collect artifacts into a dedicated folder:</p> <pre><code>cd examples\npython getting_started.py --outdir ./out/getting_started\n</code></pre> <p>Check <code>./out/getting_started</code> for PNGs and any generated model files.</p>"},{"location":"getting-started/#3-ci-friendly-runs-and-temporary-outputs","title":"3) CI-friendly runs and temporary outputs","text":"<p>All examples that create files accept an <code>--outdir</code> flag so CI runs can write artifacts to a temporary path that is cleaned up or uploaded by the pipeline. Example test-friendly pattern using <code>pytest</code>'s <code>tmp_path</code>:</p> <pre><code># inside a pytest test\nfrom pathlib import Path\nimport subprocess\n\noutdir: Path = tmp_path / \"example_out\"\noutdir.mkdir()\nsubprocess.run([\"python\", \"examples/getting_started.py\", \"--outdir\", str(outdir)], check=True)\n</code></pre> <p>Use the fake-runner (see the Examples page) in CI so tests don't require <code>ngspice</code> to be installed.</p>"},{"location":"getting-started/#4-where-to-go-next","title":"4) Where to go next","text":"<ul> <li>Examples: <code>docs/examples.md</code> \u2014 overview and per-example links.</li> <li>Monte Carlo: <code>docs/monte-carlo-example.md</code> \u2014 report format and flags.</li> <li>API: <code>docs/api-reference.md</code> \u2014 how mkdocstrings is configured and which     modules we recommend including in the API documentation.</li> </ul>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If an example fails with simulator errors, re-run with <code>--real-run</code> to     confirm against <code>ngspice</code> and inspect the generated <code>.cir</code> or <code>.sp</code> file in     the <code>--outdir</code> directory.</li> <li>If your CI environment cannot install <code>ngspice</code>, ensure the test uses the     fake-runner and that <code>--outdir</code> is set to a writable temporary directory.</li> </ul>"},{"location":"getting-started/#getting-started_1","title":"Getting started","text":"<p>Create a Circuit and build a netlist:</p> <pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import Vdc, Resistor, Capacitor\nfrom spicelab.core.net import GND\n\nc = Circuit(\"rc_lowpass\")\nV1 = Vdc(\"1\", 5.0)\nR1 = Resistor(\"1\", \"1k\")\nC1 = Capacitor(\"1\", \"100n\")\n\nc.add(V1, R1, C1)\nc.connect(V1.ports[0], R1.ports[0])\nc.connect(R1.ports[1], C1.ports[0])\nc.connect(V1.ports[1], GND)\nc.connect(C1.ports[1], GND)\n\nprint(c.build_netlist())\n</code></pre> <p>This will print a SPICE netlist ready to be executed by a SPICE runner.</p>"},{"location":"getting-started/#run-a-transient-in-one-line","title":"Run a transient in one line","text":"<p>You can run a transient (.TRAN) analysis and get a pandas DataFrame directly:</p> <pre><code>from spicelab.analysis import run_tran\n\ndf = run_tran(c, \"10us\", \"5ms\", return_df=True)\nprint(df.head())\n</code></pre> <p>Or keep the full result object for advanced usage:</p> <pre><code>res = run_tran(c, \"10us\", \"5ms\")\nprint(res.traces.names)\n</code></pre>"},{"location":"getting-started/#quickstart-script","title":"Quickstart script","text":"<p>This repository includes a runnable <code>examples/getting_started.py</code> script that walks through building a simple RC circuit and running AC, DC and transient analyses, producing PNG plots. To run the tutorial:</p> <pre><code>cd examples\nuv run --active python getting_started.py\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Install PyCircuitKit in a virtual environment:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install -e .\n</code></pre> <p>Recommended dev tools:</p> <ul> <li>pytest</li> <li>mypy</li> <li>ruff</li> </ul> <p>Optional (for docs):</p> <ul> <li>mkdocs-material</li> <li>mkdocstrings</li> </ul>"},{"location":"ltspice-import/","title":"LTspice Integration","text":"<p>CAT interoperates with LTspice in two complementary ways:</p> <ol> <li>Import netlists exported via View \u2192 SPICE Netlist (<code>.cir</code>/<code>.net</code>).</li> <li>Round-trip schematics (<code>.asc</code>) for a curated symbol library, generating    LTspice-friendly projects straight from your Python models.</li> </ol>"},{"location":"ltspice-import/#netlists-cir-net","title":"Netlists (<code>.cir</code> / <code>.net</code>)","text":"<p>Use <code>spicelab.io.ltspice_parser.from_ltspice_file</code> to parse a netlist and obtain a <code>Circuit</code> object that can be analysed, modified or exported again.</p>"},{"location":"ltspice-import/#supported-cards","title":"Supported cards","text":"<ul> <li><code>.include</code> / <code>.param</code> expansion (recursive)</li> <li>Devices: R, C, L, independent V/I (DC/AC), <code>PULSE</code>, <code>SIN</code>, <code>PWL</code></li> <li>Controlled sources: E, G, F, H</li> <li>Diodes <code>D</code></li> <li>Voltage/current controlled switches: <code>S</code> (VSWITCH), <code>W</code> (ISWITCH)</li> <li>One-level <code>.SUBCKT</code> flattening with <code>{PARAM}</code> substitution</li> </ul> <pre><code>from spicelab.io.ltspice_parser import from_ltspice_file\nfrom spicelab.analysis import run_tran\n\nc = from_ltspice_file(\"./my_filter.cir\")\ntran = run_tran(c, \"1us\", \"2ms\", return_df=True)\nprint(tran.head())\n</code></pre> <p>\u2139\ufe0f Tips - Keep <code>.model</code> statements together with the circuit or re-add them via   <code>circuit.add_directive(\".model ...\")</code>. - Unknown cards will raise a descriptive <code>ValueError</code>. If something critical is   missing, please open an issue with a minimal example.</p>"},{"location":"ltspice-import/#schematics-asc","title":"Schematics (<code>.asc</code>)","text":"<p>The module <code>spicelab.io.ltspice_asc</code> introduces helpers to load, generate and save schematic files:</p> <ul> <li><code>parse_asc(path_or_text)</code> \u2192 <code>AscSchematic</code></li> <li><code>schematic_to_circuit(AscSchematic)</code> \u2192 <code>Circuit</code></li> <li><code>circuit_to_schematic(Circuit, include_wires=True)</code> \u2192 <code>AscSchematic</code></li> <li><code>circuit_to_asc_text</code> / <code>save_circuit_as_asc</code></li> </ul>"},{"location":"ltspice-import/#when-should-i-use-spiceline","title":"When should I use <code>SpiceLine</code>?","text":"<p>The exporter attaches <code>SYMATTR SpiceLine ...</code> to every symbol with the exact SPICE card produced by spicelab. When these attributes are present the importer uses those directives verbatim, guaranteeing an exact round-trip.</p> <p>If a schematic lacks <code>SpiceLine</code>, spicelab falls back to analysing wires and symbol pins (union-find). This allows importing hand-drawn LTspice schematics, but the result may require manual clean-up if multiple nets share the same coordinates.</p>"},{"location":"ltspice-import/#supported-symbols-export","title":"Supported symbols (export)","text":"Symbol CAT component <code>res</code> <code>Resistor</code> <code>cap</code> <code>Capacitor</code> <code>ind</code> <code>Inductor</code> <code>voltage</code> <code>Vdc</code> <code>current</code> <code>Idc</code> <code>dio</code> <code>Diode</code> <code>vcvs</code> <code>VCVS</code> <code>vccs</code> <code>VCCS</code> <code>cccs</code> <code>CCCS</code> <code>ccvs</code> <code>CCVS</code> <p>Orientation is auto-selected when practical (for example, capacitors tied to GND are placed vertically).</p> <pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import Capacitor, Resistor, Vdc\nfrom spicelab.core.net import GND, Net\nfrom spicelab.io.ltspice_asc import circuit_to_asc_text, parse_asc, schematic_to_circuit\n\nvin = Net(\"vin\")\nvout = Net(\"vout\")\n\nc = Circuit(\"rc\")\nV1 = Vdc(\"1\", 5.0)\nR1 = Resistor(\"1\", \"1k\")\nC1 = Capacitor(\"1\", \"10n\")\n\nc.add(V1, R1, C1)\nc.connect(V1.ports[0], vin)\nc.connect(R1.ports[0], vin)\nc.connect(R1.ports[1], vout)\nc.connect(C1.ports[0], vout)\nc.connect(C1.ports[1], GND)\nc.connect(V1.ports[1], GND)\n\nasc_text = circuit_to_asc_text(c)\nprint(asc_text)\n\nround_trip = schematic_to_circuit(parse_asc(asc_text))\nprint(round_trip.build_netlist())\n</code></pre>"},{"location":"ltspice-import/#limitations","title":"Limitations","text":"<ul> <li>Unsupported symbols raise <code>ValueError</code>. You can still edit the exported <code>.asc</code>   in LTspice and swap symbols manually.</li> <li>The geometry fallback assumes orthogonal wires; schematics using unusual   routing may need touch-ups before importing.</li> <li><code>include_wires=False</code> produces schematic stubs that rely entirely on   <code>SpiceLine</code>. This is convenient for programmatic generation but results in   schematics without conductor art.</li> </ul>"},{"location":"ltspice-import/#converting-existing-asc","title":"Converting existing <code>.asc</code>","text":"<pre><code>from spicelab.io.ltspice_asc import circuit_from_asc\nfrom spicelab.analysis import run_ac\n\nc = circuit_from_asc(\"./filter.asc\")\nres = run_ac(c, \"dec\", 201, 10, 1e5)\nprint(res.traces.names)\n</code></pre> <p>If your schematic has symbols that CAT does not understand, consider exporting a netlist instead or filing an issue with a small reproduction.</p> <p>See also Component Library if you want to register manufacturer specific devices (for example a diode with a recommended <code>.model</code> line) and re-use them across multiple projects.</p>"},{"location":"monte-carlo-example/","title":"Monte Carlo example","text":"<p>This page documents the <code>examples/monte_carlo_demo.py</code> script and the options it accepts.</p>"},{"location":"monte-carlo-example/#quick-usage","title":"Quick usage","text":"<pre><code>python examples/monte_carlo_demo.py --n 200 --outdir ./mc_report\n</code></pre>"},{"location":"monte-carlo-example/#cli-flags-of-interest","title":"CLI flags of interest","text":"<ul> <li><code>--n</code> \u2014 number of Monte Carlo trials (default smaller number for demos).</li> <li><code>--outdir</code> \u2014 where to write plots and the HTML report.</li> <li><code>--real-run</code> \u2014 if set, the script will call <code>ngspice</code> instead of the   built-in fake-runner.</li> </ul>"},{"location":"monte-carlo-example/#report-contents","title":"Report contents","text":"<p>The script writes a small HTML file that contains:</p> <ul> <li>a table of summary statistics (mean, std, CV and percentiles)</li> <li>images with the waveform, histograms, and a parameter trace matrix</li> </ul> <p>Use <code>--outdir</code> to collect all artifacts in one place for inspection or CI upload.</p>"},{"location":"monte-carlo/","title":"Monte Carlo","text":"<p>Run Monte Carlo by mapping components to distributions and a per-trial analysis:</p> <p></p> <pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import Vdc, Resistor, Capacitor\nfrom spicelab.core.net import GND\nfrom spicelab.analysis import OP, monte_carlo, NormalPct\n\nc = Circuit(\"rc\")\nV1, R1, C1 = Vdc(\"1\", 5.0), Resistor(\"1\", \"1k\"), Capacitor(\"1\", \"100n\")\nc.add(V1, R1, C1)\nc.connect(V1.ports[0], R1.ports[0])\nc.connect(R1.ports[1], C1.ports[0])\nc.connect(V1.ports[1], GND)\nc.connect(C1.ports[1], GND)\n\nmc = monte_carlo(\n    circuit=c,\n    mapping={R1: NormalPct(0.05)},\n    n=16,\n    analysis_factory=lambda: OP(),\n    seed=123,\n)\n\ndf = mc.to_dataframe(param_prefix=\"param_\")\nprint(df.head())\n</code></pre> <p>Tips: - Use <code>workers</code> for parallel execution: <code>monte_carlo(..., workers=4)</code>. - Provide a metric function to compute scalar KPIs per trial, or set <code>y=[...]</code> and <code>sample_at</code> to extract trace values.</p>"},{"location":"monte-carlo/#progress-bar-callback","title":"Progress bar / callback","text":"<p>Add a lightweight progress bar to stderr:</p> <pre><code>mc = monte_carlo(\n    circuit=c,\n    mapping={R1: NormalPct(0.01)},\n    n=1000,\n    analysis_factory=lambda: OP(),\n    progress=True,   # prints: \"MC: 317/1000 (31%)\"\n)\n</code></pre> <p>Or provide your own callback (<code>done</code>, <code>total</code>):</p> <pre><code>def cb(done: int, total: int) -&gt; None:\n    print(f\"{done}/{total}\", end=\"\\r\")\n\nmc = monte_carlo(c, mapping={R1: NormalPct(0.01)}, n=1000,\n                 analysis_factory=lambda: OP(), progress=cb)\n</code></pre>"},{"location":"mux-enable-ports/","title":"Mux enable ports","text":""},{"location":"mux-enable-ports/#analogmux8-enable-ports-mode","title":"AnalogMux8 \u2014 Enable Ports Mode","text":"<p><code>AnalogMux8</code> (spicelab.core.components) can operate in dynamic mode by exposing enable ports <code>en0..en7</code>. Each channel uses a voltage\u2011controlled switch (<code>S...</code>) followed by a series resistor <code>r_series</code>. When an enable input is high, the corresponding channel conducts with <code>RON</code> (from the switch) and <code>r_series</code> in series; other channels remain high\u2011Z (switch <code>ROFF</code>).</p> <p>Options</p> <ul> <li><code>enable_ports=True</code>: expose <code>en0..en7</code> and emit <code>S...</code> elements.</li> <li><code>emit_model=True</code>: also emit a default <code>.model SW_&lt;ref&gt; SW(...)</code> for the switches.</li> <li><code>sw_model</code>: custom model name (defaults to <code>SW_&lt;ref&gt;</code>).</li> </ul> <p>Control polarity</p> <ul> <li>Switch control is <code>V(cp) - V(cn)</code>; the mux ties <code>cn</code> to ground so driving   <code>enX</code> high enables channel <code>X</code>.</li> </ul> <p>Example (OP)</p> <pre><code>from spicelab.core.circuit import Circuit\nfrom spicelab.core.components import AnalogMux8, Vdc, Resistor\nfrom spicelab.core.net import GND, Net\nfrom spicelab.analysis import OP\n\nc = Circuit(\"mux_en_ports\")\nvin = Net(\"vin\")\nvout = Net(\"vout\")\n\n# 5 V source at mux input\nV1 = Vdc(\"1\", 5.0)\nM = AnalogMux8(ref=\"MU1\", r_series=100.0, enable_ports=True, emit_model=True)\nRL = Resistor(\"L\", 1000.0)\n\nc.add(V1, M, RL)\nc.connect(V1.ports[0], vin); c.connect(V1.ports[1], GND)\nc.connect(M.ports[0], vin)           # in\nc.connect(M.ports[1 + 2], vout)      # out2 -&gt; vout\n# Terminate other outputs if needed; for OP leave them floating or to GND\n\n# Load at vout\nc.connect(RL.ports[0], vout); c.connect(RL.ports[1], GND)\n\n# Drive enables: en2=1 V (on), others 0 V (off)\nfor i in range(8):\n    V_en = Vdc(f\"EN{i}\", 1.0 if i == 2 else 0.0)\n    c.add(V_en)\n    c.connect(V_en.ports[0], M.ports[1 + 8 + i])  # en ports follow the 8 outputs\n    c.connect(V_en.ports[1], GND)\n\nr = OP().run(c)\nprint(\"V(vout)=\", float(r.traces[\"v(vout)\"].values[-1]))\n</code></pre> <p>Expected result</p> <ul> <li>With <code>SW</code> model <code>RON=10</code> and <code>r_series=100</code>, and <code>RL=1k</code>, a static divider   yields <code>Vout \u2248 5 V \u00d7 1k / (1k + 10 + 100)</code>.</li> </ul> <p>Notes</p> <ul> <li>For time\u2011varying enables use <code>Vpulse</code> sources on selected <code>enX</code> nets and   run a <code>TRAN</code> analysis to observe switching.</li> <li>If you prefer your own switch model, pass <code>sw_model=\"MY_SW\"</code> and add a   <code>.model MY_SW SW(...)</code> via <code>c.add_directive()</code>.</li> </ul>"},{"location":"opamp-stability/","title":"Op-Amp Stability","text":"<p>Analyze closed-loop Bode and margins using the ideal op-amp helper.</p> <p></p>"},{"location":"opamp-stability/#inverting-topology-with-ideal-oa","title":"Inverting topology with ideal OA","text":"<pre><code>from spicelab import Circuit, GND, opamp_inverting\nfrom spicelab.core.components import VA, R\nfrom spicelab.core.net import Net\nfrom spicelab.analysis import AC, ac_gain_phase, phase_margin, gain_margin_db\n\nc = Circuit(\"opamp_inv\")\n\n# Small-signal input (1 V)\nvin = VA(ac_mag=1.0); c.add(vin)\n\n# Output/load node\nvout = Net(\"vout\"); load = R(\"10k\"); c.add(load)\nc.connect(load.ports[0], vout); c.connect(load.ports[1], GND)\n\n# Inverting amplifier: gain = -Rf/Rin = -100k/10k = -10\nopamp_inverting(c, inp=vin.ports[0], out=vout, ref=GND, Rin=\"10k\", Rf=\"100k\", gain=1e6)\nc.connect(vin.ports[1], GND)\n\nres = AC(\"dec\", 201, 10.0, 1e6).run(c)\nf, mag_db, ph = ac_gain_phase(res.traces, \"v(n1)\")\npm = phase_margin(res.traces, \"v(n1)\")\ngm = gain_margin_db(res.traces, \"v(n1)\")\nprint(pm, gm)\n</code></pre> <p>Notes: - The ideal OA is modeled as a high-gain VCVS; no power rails needed. - Use <code>plot_bode(ts, y).show()</code> to render interactive Bode charts (requires the <code>viz</code> extra). - <code>phase_margin</code> falls back to estimate if phase is missing; provide complex or phase info when possible.</p> <p>See also the runnable script under <code>examples/opamp_stability.py</code>.</p>"},{"location":"plots/","title":"Plotting","text":"<p>CAT ships interactive Plotly helpers for common visualization tasks. Each helper returns a <code>VizFigure</code>, which wraps the underlying Plotly figure and exposes <code>show()</code>, <code>to_html()</code>, and <code>to_image()</code> convenience methods.</p> <p>Install the optional <code>viz</code> extra to pull in Plotly and Kaleido (for static image export):</p> <pre><code>pip install spicelab[viz]\n</code></pre>"},{"location":"plots/#time-domain-traces","title":"Time-domain traces","text":"<pre><code>from spicelab.analysis.viz.plot import plot_traces\n\nfig = plot_traces(res.traces, ys=[\"v(n1)\", \"i(R1)\"], title=\"RC response\")\nfig.to_html(\"rc_response.html\")  # standalone HTML with embedded Plotly figure\n</code></pre>"},{"location":"plots/#bode-plots","title":"Bode plots","text":"<pre><code>from spicelab.analysis.viz.plot import plot_bode\n\n# 'y' must reference a complex trace (AC/Small-signal analysis)\nbode_fig = plot_bode(res.traces, y=\"v(vout)\")\nbode_fig.show()  # open an interactive browser window\n</code></pre>"},{"location":"plots/#parameter-sweeps","title":"Parameter sweeps","text":"<pre><code>from spicelab.analysis.viz.plot import plot_sweep_df\n\nfig = plot_sweep_df(df, x=\"time\", y=\"v(vout)\", hue=\"R\", title=\"Parameter sweep\")\nfig.to_image(\"sweep.png\")  # requires kaleido; falls back to HTML otherwise\n</code></pre> <p>Explore <code>spicelab.viz</code> for lower-level building blocks (<code>time_series_view</code>, <code>bode_view</code>, <code>monte_carlo_histogram</code>, <code>monte_carlo_param_scatter</code>, etc.) when you want to assemble custom dashboards or compose multiple views manually.</p>"},{"location":"preview/","title":"Circuit Preview (Summary and Graphviz)","text":"<p>Use the preview helpers to validate connectivity and generate a quick Graphviz-based diagram of nets and components (no schematic rendering).</p>"},{"location":"preview/#connectivity-summary","title":"Connectivity summary","text":"<pre><code>print(c.summary())\n</code></pre> <p>Outputs a compact mapping of <code>ref.port -&gt; net</code>, highlights nets with degree 1 and unconnected ports.</p>"},{"location":"preview/#graphviz-rendering","title":"Graphviz rendering","text":"<pre><code>dot = c.to_dot()\n# render_svg() will call out to the `dot` binary if available; otherwise you can run dot manually:\nok = c.render_svg(\"circuit_preview.svg\")  # requires 'dot' in PATH\n</code></pre> <p>If Graphviz isn't installed, you still get a <code>.dot</code> file:</p> <pre><code>dot -Tsvg circuit_preview.dot -o preview.svg\n</code></pre> <p>Example (RC low-pass):</p> <p></p>"},{"location":"preview/#netlist-helpers","title":"Netlist helpers","text":"<pre><code>print(c.netlist_string())\n# or\nc.print_netlist()\n</code></pre>"},{"location":"preview/#monte-carlo-quick-export-plots","title":"Monte Carlo \u2014 quick export &amp; plots","text":"<pre><code># run a Monte Carlo varying components (example only)\nfrom spicelab.analysis.montecarlo import monte_carlo, NormalPct\nfrom spicelab.analysis.core import TRAN\n\n# mapping would be Component -&gt; Dist (here pseudo-code)\n# mc = monte_carlo(circuit, mapping, n=100, analysis_factory=lambda: TRAN('1e-6','1e-3'))\n\n# export sampled parameters and the manifest\n# mc.save_samples_csv('mc_samples.csv')\n# mc.save_manifest_csv('mc_manifest.csv')\n\n# compute a metric per run (example: final Vout) and plot\n# metrics = [my_metric(r) for r in mc.runs]\n# from spicelab.analysis.viz.plot import plot_mc_metric_hist, plot_param_vs_metric\n# fig_hist = plot_mc_metric_hist(metrics, title='Gain distribution')\n# fig_scatter = plot_param_vs_metric(mc.samples, metrics, param='R1')\n</code></pre> <p>Example outputs (generated by <code>examples/mc_demo_plots.py</code>):</p> <p></p> <p></p> <p></p>"},{"location":"sweeps-step/","title":"Sweeps and .STEP","text":"<p>There are two ways to sweep parameters:</p> <ul> <li>Python-side sweeps (<code>step_param</code>, <code>step_grid</code>) \u2014 easiest to combine with Pandas.</li> <li>Native SPICE <code>.step</code> directives \u2014 use <code>run_step_native</code> to parse multi-plot RAW.</li> </ul> <p></p>"},{"location":"sweeps-step/#python-sweeps","title":"Python sweeps","text":"<p>Single parameter:</p> <pre><code>from spicelab.analysis import step_param, TRAN\nres = step_param(\n    c,\n    name=\"R\",\n    values=[\"1k\",\"2k\",\"5k\"],\n    analysis_factory=lambda: TRAN(\"50us\",\"5ms\"),\n    progress=True,   # prints progress to stderr\n)\n</code></pre> <p>Grid of parameters:</p> <pre><code>from spicelab.analysis import ParamGrid, step_grid\ngrid: ParamGrid = {\"R\": [\"1k\",\"2k\"], \"C\": [\"100n\",\"220n\"]}\nstep = step_grid(c, grid, analysis_factory=lambda: TRAN(\"50us\",\"5ms\"), progress=True)\n</code></pre> <p>Stacking to DataFrame:</p> <pre><code>from spicelab.analysis import stack_step_to_df\ndf = stack_step_to_df(step, y=[\"v(n1)\"], with_x=True)\n</code></pre> <p>Plotting grouped curves (optional):</p> <pre><code>from spicelab.analysis.viz.plot import plot_sweep_df\nfig = plot_sweep_df(df, x=\"time\", y=\"v(n1)\", hue=\"R\")\n\n### Custom progress callback\n\nYou can pass a function `callback(done, total)` to receive updates instead of the default bar:\n\n```python\ndef cb(done: int, total: int) -&gt; None:\n    print(f\"{done}/{total}\", end=\"\\r\")\n\nstep = step_grid(c, grid, analysis_factory=lambda: TRAN(\"50us\",\"5ms\"), progress=cb)\n</code></pre> <pre><code>\n## Native .STEP\n\nProvide directives that include `.step` and parse all plots:\n```python\nfrom spicelab.analysis import run_step_native\nout = run_step_native(c, directives=[\".step param R list 1k 2k 5k\", \".tran 50us 5ms\"])\nsets = out.tracesets  # list[TraceSet]\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<ul> <li>ngspice not found: install it and ensure it's on PATH.</li> <li>macOS: <code>brew install ngspice</code></li> <li>Ubuntu: <code>sudo apt install -y ngspice</code></li> <li>Windows: install Spice64 and add the <code>bin</code> to PATH</li> <li>Binary RAW: <code>Binary RAW not supported yet</code> \u2192 we force ASCII in our runner, but if you   run NGSpice manually, set <code>set filetype=ascii</code> in a <code>.control</code> block or use <code>-r</code>.</li> <li>Unconnected port: connect every component port to a Net or another Port before building.</li> <li>Missing .model for switches: add directives with <code>circuit.add_directive(\".model ...\")</code>.</li> <li>AC analysis looks flat or phase missing: ensure you use small-signal sources (VA/Iac),   or reconstruct complex traces with <code>ac_gain_phase</code> which handles re/im or mag/phase.</li> </ul>"},{"location":"reference/analysis/","title":"Analysis API","text":"<p>Placeholder for analysis API docs.</p>"},{"location":"reference/analysis/#spicelab.analysis.Bode","title":"<code>Bode</code>  <code>dataclass</code>","text":"<p>Container opcional para quem preferir um objeto tipado.</p> Source code in <code>spicelab/analysis/metrics_ac.py</code> <pre><code>@dataclass(frozen=True)\nclass Bode:\n    \"\"\"Container opcional para quem preferir um objeto tipado.\"\"\"\n\n    f: NDArray[Any]  # Hz\n    mag_db: NDArray[Any]  # dB\n    ph_deg: NDArray[Any]  # graus\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.MonteCarloResult","title":"<code>MonteCarloResult</code>  <code>dataclass</code>","text":"Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>@dataclass(frozen=True)\nclass MonteCarloResult:\n    samples: list[dict[str, float]]\n    runs: list[AnalysisResult]\n    # optional metadata about the varied parameters: list of (label, nominal, dist_repr)\n    mapping_manifest: list[tuple[str, float, str]] | None = None\n\n    def to_dataframe(\n        self,\n        metric: (\n            Callable[[AnalysisResult], float | dict[str, Any]]\n            | TMapping[str, Callable[[AnalysisResult], Any]]\n            | None\n        ) = None,\n        *,\n        trial_name: str = \"trial\",\n        param_prefix: str = \"\",\n        y: Sequence[str] | None = None,\n        sample_at: float | None = None,\n    ) -&gt; Any:\n        \"\"\"\n        Returns a per-trial DataFrame with columns:\n          - trial (index within this Monte Carlo run)\n          - one column per sampled parameter (from `samples`), optionally prefixed\n          - optional metric columns computed from each AnalysisResult\n          - optional raw trace columns (final value or sampled at `sample_at` seconds)\n\n        metric:\n          - callable \u2192 result stored in column 'metric' (float or scalar)\n          - mapping name-&gt;callable \u2192 adds one column per metric name\n        y: list of trace names to extract values for each run. If `sample_at` is given,\n           the value is linearly interpolated at t=sample_at using the run's time axis;\n           otherwise, the last value in the trace is used.\n        \"\"\"\n        try:\n            pd: Any = importlib.import_module(\"pandas\")\n        except Exception:  # pragma: no cover\n            pd = None\n\n        rows: list[dict[str, Any]] = []\n        for i, (s, run) in enumerate(zip(self.samples, self.runs, strict=False)):\n            # copy sampled params; optionally add prefix\n            if param_prefix:\n                row = {f\"{param_prefix}{k}\": v for k, v in s.items()}\n            else:\n                row = dict(s)\n            row[trial_name] = i\n            if metric is not None:\n                if hasattr(metric, \"items\"):\n                    for name, fn in cast(\n                        TMapping[str, Callable[[AnalysisResult], Any]], metric\n                    ).items():\n                        row[name] = fn(run)\n                else:\n                    m = cast(Callable[[AnalysisResult], Any], metric)(run)\n                    if isinstance(m, dict):\n                        row.update(m)\n                    else:\n                        row[\"metric\"] = m\n\n            if y:\n                try:\n                    import numpy as _np  # local import to avoid hard dep at module import\n                except Exception:  # pragma: no cover\n                    _np = None  # type: ignore[assignment]\n\n                ts = run.traces\n                # pick x axis name\n                xname = getattr(ts.x, \"name\", \"time\")\n                for name in y:\n                    vals = ts[name].values\n                    if sample_at is not None and _np is not None and xname.lower() == \"time\":\n                        t = ts[xname].values\n                        row[name] = float(_np.interp(sample_at, t, vals))\n                    else:\n                        row[name] = (\n                            float(vals[-1]) if len(vals) else _np.nan if _np is not None else 0.0\n                        )\n            rows.append(row)\n        if pd is None:\n            return _MiniDataFrame(rows)\n        return pd.DataFrame(rows)\n\n    def to_csv(\n        self,\n        path: str,\n        metric: (\n            Callable[[AnalysisResult], float | dict[str, Any]]\n            | TMapping[str, Callable[[AnalysisResult], Any]]\n            | None\n        ) = None,\n        *,\n        trial_name: str = \"trial\",\n        param_prefix: str = \"\",\n        y: Sequence[str] | None = None,\n        sample_at: float | None = None,\n        columns: Sequence[str] | None = None,\n        index: bool = False,\n        **to_csv_kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Write the Monte Carlo per-trial table to CSV.\n\n        - `path`: output file path (passed to pandas.DataFrame.to_csv).\n        - `metric`, `trial_name`, `param_prefix`, `y`, `sample_at` are forwarded\n          to :meth:`to_dataframe` and behave the same.\n        - `columns`: optional sequence of column names to keep (order preserved).\n        - `index`: whether to write the DataFrame index (default False).\n        - `to_csv_kwargs`: additional keyword args passed to pandas.DataFrame.to_csv.\n\n        Raises RuntimeError if pandas is not available.\n        \"\"\"\n        try:\n            importlib.import_module(\"pandas\")\n        except Exception as exc:  # pragma: no cover\n            raise RuntimeError(\"pandas is required for MonteCarloResult.to_csv()\") from exc\n\n        df = self.to_dataframe(\n            metric=metric,\n            trial_name=trial_name,\n            param_prefix=param_prefix,\n            y=y,\n            sample_at=sample_at,\n        )\n        if columns is not None:\n            df = df.loc[:, list(columns)]\n        df.to_csv(path, index=index, **to_csv_kwargs)\n\n    def save_samples_csv(\n        self, path: str, *, param_prefix: str = \"\", index: bool = False, **to_csv_kwargs: Any\n    ) -&gt; None:\n        \"\"\"Write only the sampled parameters (and trial index) to CSV.\n\n        This is a convenience helper that writes the per-trial sampled parameters\n        (the entries produced when generating the Monte Carlo `samples`) to a CSV\n        file. Columns are the sampled parameter names (optionally prefixed) and\n        the trial column named 'trial'.\n        \"\"\"\n        try:\n            importlib.import_module(\"pandas\")\n        except Exception as exc:  # pragma: no cover\n            raise RuntimeError(\n                \"pandas is required for MonteCarloResult.save_samples_csv()\"\n            ) from exc\n\n        df = self.to_dataframe(metric=None, trial_name=\"trial\", param_prefix=param_prefix, y=None)\n        df.to_csv(path, index=index, **to_csv_kwargs)\n\n    def save_manifest_csv(self, path: str, *, index: bool = False, **to_csv_kwargs: Any) -&gt; None:\n        \"\"\"Write a small manifest describing the varied parameters to CSV.\n\n        The manifest columns are: label, nominal, dist. The manifest is taken from\n        `mapping_manifest` populated by the `monte_carlo` helper when available.\n        \"\"\"\n        try:\n            importlib.import_module(\"pandas\")\n        except Exception as exc:  # pragma: no cover\n            raise RuntimeError(\n                \"pandas is required for MonteCarloResult.save_manifest_csv()\"\n            ) from exc\n\n        if not self.mapping_manifest:\n            # nothing to write\n            return\n\n        import pandas as pd  # type: ignore[import-untyped]  # local import; optional runtime dependency\n\n        df = pd.DataFrame(self.mapping_manifest, columns=[\"label\", \"nominal\", \"dist\"])\n        df.to_csv(path, index=index, **to_csv_kwargs)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.MonteCarloResult.save_manifest_csv","title":"<code>save_manifest_csv(path, *, index=False, **to_csv_kwargs)</code>","text":"<p>Write a small manifest describing the varied parameters to CSV.</p> <p>The manifest columns are: label, nominal, dist. The manifest is taken from <code>mapping_manifest</code> populated by the <code>monte_carlo</code> helper when available.</p> Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>def save_manifest_csv(self, path: str, *, index: bool = False, **to_csv_kwargs: Any) -&gt; None:\n    \"\"\"Write a small manifest describing the varied parameters to CSV.\n\n    The manifest columns are: label, nominal, dist. The manifest is taken from\n    `mapping_manifest` populated by the `monte_carlo` helper when available.\n    \"\"\"\n    try:\n        importlib.import_module(\"pandas\")\n    except Exception as exc:  # pragma: no cover\n        raise RuntimeError(\n            \"pandas is required for MonteCarloResult.save_manifest_csv()\"\n        ) from exc\n\n    if not self.mapping_manifest:\n        # nothing to write\n        return\n\n    import pandas as pd  # type: ignore[import-untyped]  # local import; optional runtime dependency\n\n    df = pd.DataFrame(self.mapping_manifest, columns=[\"label\", \"nominal\", \"dist\"])\n    df.to_csv(path, index=index, **to_csv_kwargs)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.MonteCarloResult.save_samples_csv","title":"<code>save_samples_csv(path, *, param_prefix='', index=False, **to_csv_kwargs)</code>","text":"<p>Write only the sampled parameters (and trial index) to CSV.</p> <p>This is a convenience helper that writes the per-trial sampled parameters (the entries produced when generating the Monte Carlo <code>samples</code>) to a CSV file. Columns are the sampled parameter names (optionally prefixed) and the trial column named 'trial'.</p> Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>def save_samples_csv(\n    self, path: str, *, param_prefix: str = \"\", index: bool = False, **to_csv_kwargs: Any\n) -&gt; None:\n    \"\"\"Write only the sampled parameters (and trial index) to CSV.\n\n    This is a convenience helper that writes the per-trial sampled parameters\n    (the entries produced when generating the Monte Carlo `samples`) to a CSV\n    file. Columns are the sampled parameter names (optionally prefixed) and\n    the trial column named 'trial'.\n    \"\"\"\n    try:\n        importlib.import_module(\"pandas\")\n    except Exception as exc:  # pragma: no cover\n        raise RuntimeError(\n            \"pandas is required for MonteCarloResult.save_samples_csv()\"\n        ) from exc\n\n    df = self.to_dataframe(metric=None, trial_name=\"trial\", param_prefix=param_prefix, y=None)\n    df.to_csv(path, index=index, **to_csv_kwargs)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.MonteCarloResult.to_csv","title":"<code>to_csv(path, metric=None, *, trial_name='trial', param_prefix='', y=None, sample_at=None, columns=None, index=False, **to_csv_kwargs)</code>","text":"<p>Write the Monte Carlo per-trial table to CSV.</p> <ul> <li><code>path</code>: output file path (passed to pandas.DataFrame.to_csv).</li> <li><code>metric</code>, <code>trial_name</code>, <code>param_prefix</code>, <code>y</code>, <code>sample_at</code> are forwarded   to :meth:<code>to_dataframe</code> and behave the same.</li> <li><code>columns</code>: optional sequence of column names to keep (order preserved).</li> <li><code>index</code>: whether to write the DataFrame index (default False).</li> <li><code>to_csv_kwargs</code>: additional keyword args passed to pandas.DataFrame.to_csv.</li> </ul> <p>Raises RuntimeError if pandas is not available.</p> Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>def to_csv(\n    self,\n    path: str,\n    metric: (\n        Callable[[AnalysisResult], float | dict[str, Any]]\n        | TMapping[str, Callable[[AnalysisResult], Any]]\n        | None\n    ) = None,\n    *,\n    trial_name: str = \"trial\",\n    param_prefix: str = \"\",\n    y: Sequence[str] | None = None,\n    sample_at: float | None = None,\n    columns: Sequence[str] | None = None,\n    index: bool = False,\n    **to_csv_kwargs: Any,\n) -&gt; None:\n    \"\"\"Write the Monte Carlo per-trial table to CSV.\n\n    - `path`: output file path (passed to pandas.DataFrame.to_csv).\n    - `metric`, `trial_name`, `param_prefix`, `y`, `sample_at` are forwarded\n      to :meth:`to_dataframe` and behave the same.\n    - `columns`: optional sequence of column names to keep (order preserved).\n    - `index`: whether to write the DataFrame index (default False).\n    - `to_csv_kwargs`: additional keyword args passed to pandas.DataFrame.to_csv.\n\n    Raises RuntimeError if pandas is not available.\n    \"\"\"\n    try:\n        importlib.import_module(\"pandas\")\n    except Exception as exc:  # pragma: no cover\n        raise RuntimeError(\"pandas is required for MonteCarloResult.to_csv()\") from exc\n\n    df = self.to_dataframe(\n        metric=metric,\n        trial_name=trial_name,\n        param_prefix=param_prefix,\n        y=y,\n        sample_at=sample_at,\n    )\n    if columns is not None:\n        df = df.loc[:, list(columns)]\n    df.to_csv(path, index=index, **to_csv_kwargs)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.MonteCarloResult.to_dataframe","title":"<code>to_dataframe(metric=None, *, trial_name='trial', param_prefix='', y=None, sample_at=None)</code>","text":"Returns a per-trial DataFrame with columns <ul> <li>trial (index within this Monte Carlo run)</li> <li>one column per sampled parameter (from <code>samples</code>), optionally prefixed</li> <li>optional metric columns computed from each AnalysisResult</li> <li>optional raw trace columns (final value or sampled at <code>sample_at</code> seconds)</li> </ul> metric <ul> <li>callable \u2192 result stored in column 'metric' (float or scalar)</li> <li>mapping name-&gt;callable \u2192 adds one column per metric name</li> </ul> <p>y: list of trace names to extract values for each run. If <code>sample_at</code> is given,    the value is linearly interpolated at t=sample_at using the run's time axis;    otherwise, the last value in the trace is used.</p> Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>def to_dataframe(\n    self,\n    metric: (\n        Callable[[AnalysisResult], float | dict[str, Any]]\n        | TMapping[str, Callable[[AnalysisResult], Any]]\n        | None\n    ) = None,\n    *,\n    trial_name: str = \"trial\",\n    param_prefix: str = \"\",\n    y: Sequence[str] | None = None,\n    sample_at: float | None = None,\n) -&gt; Any:\n    \"\"\"\n    Returns a per-trial DataFrame with columns:\n      - trial (index within this Monte Carlo run)\n      - one column per sampled parameter (from `samples`), optionally prefixed\n      - optional metric columns computed from each AnalysisResult\n      - optional raw trace columns (final value or sampled at `sample_at` seconds)\n\n    metric:\n      - callable \u2192 result stored in column 'metric' (float or scalar)\n      - mapping name-&gt;callable \u2192 adds one column per metric name\n    y: list of trace names to extract values for each run. If `sample_at` is given,\n       the value is linearly interpolated at t=sample_at using the run's time axis;\n       otherwise, the last value in the trace is used.\n    \"\"\"\n    try:\n        pd: Any = importlib.import_module(\"pandas\")\n    except Exception:  # pragma: no cover\n        pd = None\n\n    rows: list[dict[str, Any]] = []\n    for i, (s, run) in enumerate(zip(self.samples, self.runs, strict=False)):\n        # copy sampled params; optionally add prefix\n        if param_prefix:\n            row = {f\"{param_prefix}{k}\": v for k, v in s.items()}\n        else:\n            row = dict(s)\n        row[trial_name] = i\n        if metric is not None:\n            if hasattr(metric, \"items\"):\n                for name, fn in cast(\n                    TMapping[str, Callable[[AnalysisResult], Any]], metric\n                ).items():\n                    row[name] = fn(run)\n            else:\n                m = cast(Callable[[AnalysisResult], Any], metric)(run)\n                if isinstance(m, dict):\n                    row.update(m)\n                else:\n                    row[\"metric\"] = m\n\n        if y:\n            try:\n                import numpy as _np  # local import to avoid hard dep at module import\n            except Exception:  # pragma: no cover\n                _np = None  # type: ignore[assignment]\n\n            ts = run.traces\n            # pick x axis name\n            xname = getattr(ts.x, \"name\", \"time\")\n            for name in y:\n                vals = ts[name].values\n                if sample_at is not None and _np is not None and xname.lower() == \"time\":\n                    t = ts[xname].values\n                    row[name] = float(_np.interp(sample_at, t, vals))\n                else:\n                    row[name] = (\n                        float(vals[-1]) if len(vals) else _np.nan if _np is not None else 0.0\n                    )\n        rows.append(row)\n    if pd is None:\n        return _MiniDataFrame(rows)\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.RiseFall","title":"<code>RiseFall</code>  <code>dataclass</code>","text":"<p>Tempos de subida/descida entre fra\u00e7\u00f5es de n\u00edvel (ex.: 10%\u219290%).</p> Source code in <code>spicelab/analysis/metrics_tran.py</code> <pre><code>@dataclass(frozen=True)\nclass RiseFall:\n    \"\"\"Tempos de subida/descida entre fra\u00e7\u00f5es de n\u00edvel (ex.: 10%\u219290%).\"\"\"\n\n    trise: float | None\n    tfall: float | None\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.ac_gain_phase","title":"<code>ac_gain_phase(ts, y_out, y_in=None)</code>","text":"<p>Retorna (f, mag_db, fase_deg).</p> Source code in <code>spicelab/analysis/metrics_ac.py</code> <pre><code>def ac_gain_phase(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str | None = None,\n) -&gt; tuple[NDArray[Any], NDArray[Any], NDArray[Any]]:\n    \"\"\"Retorna (f, mag_db, fase_deg).\"\"\"\n    return _get_xy_ac(ts, y_out=y_out, y_in=y_in)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.bandwidth_3db","title":"<code>bandwidth_3db(ts, y_out, y_in=None)</code>","text":"<p>Frequ\u00eancia -3 dB relativa ao ganho de baixa frequ\u00eancia.</p> Source code in <code>spicelab/analysis/metrics_ac.py</code> <pre><code>def bandwidth_3db(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str | None = None,\n) -&gt; float | None:\n    \"\"\"Frequ\u00eancia -3 dB relativa ao ganho de baixa frequ\u00eancia.\"\"\"\n    f, mag_db, _ = ac_gain_phase(ts, y_out=y_out, y_in=y_in)\n    g0 = float(mag_db[0])\n    target = g0 - 3.0\n    below = np.where(mag_db &lt;= target)[0]\n    if below.size == 0:\n        return None\n    i = below[0]\n    if i == 0:\n        return float(f[0])\n    x0, x1 = f[i - 1], f[i]\n    y0, y1 = mag_db[i - 1], mag_db[i]\n    if np.isclose(y1, y0):\n        return float(x1)\n    w = (target - y0) / (y1 - y0)\n    return float(x0 + w * (x1 - x0))\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.bode","title":"<code>bode(circuit, y_out, y_in=None, *, sweep_type='dec', n=201, fstart=10.0, fstop=1000000.0)</code>","text":"<p>Run AC and return (f, |G|_dB, phase_deg) using spicelab.analysis.metrics_ac.</p> <p>Note: The circuit must include appropriate small-signal sources for AC analysis.</p> Source code in <code>spicelab/analysis/__init__.py</code> <pre><code>def bode(\n    circuit: Circuit,\n    y_out: str,\n    y_in: str | None = None,\n    *,\n    sweep_type: str = \"dec\",\n    n: int = 201,\n    fstart: float = 10.0,\n    fstop: float = 1e6,\n) -&gt; tuple[Any, Any, Any]:\n    \"\"\"Run AC and return (f, |G|_dB, phase_deg) using spicelab.analysis.metrics_ac.\n\n    Note: The circuit must include appropriate small-signal sources for AC analysis.\n    \"\"\"\n    res = AC(sweep_type, n, fstart, fstop).run(circuit)\n    return ac_gain_phase(res.traces, y_out=y_out, y_in=y_in)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.crossover_freq_0db","title":"<code>crossover_freq_0db(ts, y_out, y_in=None)</code>","text":"<p>Frequ\u00eancia em que |G| cruza 0 dB.</p> Source code in <code>spicelab/analysis/metrics_ac.py</code> <pre><code>def crossover_freq_0db(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str | None = None,\n) -&gt; float | None:\n    \"\"\"Frequ\u00eancia em que |G| cruza 0 dB.\"\"\"\n    f, mag_db, _ = ac_gain_phase(ts, y_out=y_out, y_in=y_in)\n    y = mag_db\n    s = np.sign(y)\n    idx = np.where((s[:-1] &gt;= 0) &amp; (s[1:] &lt;= 0) | (s[:-1] &lt;= 0) &amp; (s[1:] &gt;= 0))[0]\n    if idx.size == 0:\n        return None\n    i = int(idx[0])\n    x0, x1 = f[i], f[i + 1]\n    y0, y1 = y[i], y[i + 1]\n    if np.isclose(y1, y0):\n        return float(x0)\n    w = (0.0 - y0) / (y1 - y0)\n    return float(x0 + w * (x1 - x0))\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.fall_time","title":"<code>fall_time(ts, y_name, frac_low=0.1, frac_high=0.9)</code>","text":"<p>Tempo 90\u201310% (por padr\u00e3o). Retorna RiseFall com .tfall (e .trise=None).</p> <p>Estrat\u00e9gia robusta an\u00e1loga \u00e0 de subida, mas do n\u00edvel alto para o baixo.</p> Source code in <code>spicelab/analysis/metrics_tran.py</code> <pre><code>def fall_time(\n    ts: TraceSet,\n    y_name: str,\n    frac_low: float = 0.1,\n    frac_high: float = 0.9,\n) -&gt; RiseFall:\n    \"\"\"\n    Tempo 90\u201310% (por padr\u00e3o). Retorna RiseFall com .tfall (e .trise=None).\n\n    Estrat\u00e9gia robusta an\u00e1loga \u00e0 de subida, mas do n\u00edvel alto para o baixo.\n    \"\"\"\n    x, y = _get_xy(ts, y_name)\n    y0 = float(y[0])\n    yf = float(y[-1])\n    y_min = float(np.min(y))\n    y_max = float(np.max(y))\n    span_end = y0 - yf\n    span_global = y_max - y_min\n\n    if span_end &gt; 1e-15:\n        hi = yf + (1.0 - frac_high) * span_end  # pr\u00f3ximo de y0\n        lo = yf + (1.0 - frac_low) * span_end\n    elif span_global &gt; 1e-15:\n        hi = y_max - frac_high * span_global\n        lo = y_max - frac_low * span_global\n    else:\n        return RiseFall(trise=None, tfall=None)\n\n    t_hi = _cross_time(x, y, hi)\n    t_lo = _cross_time(x, y, lo)\n\n    if t_hi is None:\n        t_hi = _interp_time_fall(x, y, hi)\n    if t_lo is None:\n        t_lo = _interp_time_fall(x, y, lo)\n\n    if t_hi is None:\n        t_hi = _discrete_time_first_at_or_above(x, y[::-1], hi)\n    if t_lo is None:\n        t_lo = _discrete_time_first_at_or_above(x, y[::-1], lo)\n\n    if t_hi is None or t_lo is None:\n        return RiseFall(trise=None, tfall=None)\n\n    dt = float(t_lo - t_hi)\n    if dt &lt; 0.0:\n        dt = 0.0\n    return RiseFall(trise=None, tfall=dt)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.gain_at","title":"<code>gain_at(ts, y_out, f_hz, y_in=None)</code>","text":"<p>Ganho (dB) em f_hz.</p> Source code in <code>spicelab/analysis/metrics_ac.py</code> <pre><code>def gain_at(\n    ts: TraceSet,\n    y_out: str,\n    f_hz: float,\n    y_in: str | None = None,\n) -&gt; float:\n    \"\"\"Ganho (dB) em f_hz.\"\"\"\n    f, mag_db, _ = ac_gain_phase(ts, y_out=y_out, y_in=y_in)\n    return _interp_at_x(f, mag_db, f_hz)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.gain_db_from_traces","title":"<code>gain_db_from_traces(ts, y_name)</code>","text":"<p>\"Ganho\" DC aproximado, usando a diferen\u00e7a final - inicial do tra\u00e7o (em dB do delta). \u00c9 um helper simples para testes; n\u00e3o \u00e9 igual a ganho AC.</p> Source code in <code>spicelab/analysis/metrics_basic.py</code> <pre><code>def gain_db_from_traces(ts: TraceSet, y_name: str) -&gt; float:\n    \"\"\"\n    \"Ganho\" DC aproximado, usando a diferen\u00e7a final - inicial do tra\u00e7o (em dB do delta).\n    \u00c9 um helper simples para testes; n\u00e3o \u00e9 igual a ganho AC.\n    \"\"\"\n    arr = _vals(ts, y_name)\n    if arr.size == 0:\n        return -300.0\n    v = float(arr[-1] - arr[0])\n    if v == 0.0:\n        return -300.0\n    return float(20.0 * np.log10(abs(v)))\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.gain_margin_db","title":"<code>gain_margin_db(ts, y_out, y_in=None)</code>","text":"<p>Ganho em dB quando fase = -180\u00b0 (margem de ganho).</p> Source code in <code>spicelab/analysis/metrics_ac.py</code> <pre><code>def gain_margin_db(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str | None = None,\n) -&gt; float | None:\n    \"\"\"Ganho em dB quando fase = -180\u00b0 (margem de ganho).\"\"\"\n    f180 = phase_crossover_freq(ts, y_out=y_out, y_in=y_in, target_deg=-180.0)\n    if f180 is None:\n        return None\n    return gain_at(ts, y_out=y_out, y_in=y_in, f_hz=f180)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.loop_gain_bode","title":"<code>loop_gain_bode(ts, y_out, y_in)</code>","text":"<p>Retorna Bode do loop (y_out / y_in) como tupla (f, mag_db, fase).</p> Source code in <code>spicelab/analysis/metrics_ac.py</code> <pre><code>def loop_gain_bode(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str,\n) -&gt; tuple[NDArray[Any], NDArray[Any], NDArray[Any]]:\n    \"\"\"Retorna Bode do loop (y_out / y_in) como tupla (f, mag_db, fase).\"\"\"\n    return ac_gain_phase(ts, y_out=y_out, y_in=y_in)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.monte_carlo","title":"<code>monte_carlo(circuit, mapping, n, analysis_factory, seed=None, label_fn=None, workers=1, progress=None)</code>","text":"<p>Executa Monte Carlo variando valores dos componentes conforme distribui\u00e7\u00f5es.</p> Source code in <code>spicelab/analysis/montecarlo.py</code> <pre><code>def monte_carlo(\n    circuit: Circuit,\n    mapping: Mapping[Component, Dist],\n    n: int,\n    analysis_factory: Callable[[], _RunsAnalysis],\n    seed: int | None = None,\n    label_fn: Callable[[Component], str] | None = None,\n    workers: int = 1,\n    progress: bool | Callable[[int, int], None] | None = None,\n) -&gt; MonteCarloResult:\n    \"\"\"\n    Executa Monte Carlo variando valores dos componentes conforme distribui\u00e7\u00f5es.\n    \"\"\"\n    rnd = _random.Random(seed)\n\n    def _label(c: Component) -&gt; str:\n        if label_fn:\n            return label_fn(c)\n        return f\"{type(c).__name__}.{c.ref}\"\n\n    comps: list[Component] = list(mapping.keys())\n    nominals: list[float] = [_as_float(c.value) for c in comps]\n    dists: list[Dist] = [mapping[c] for c in comps]\n\n    samples: list[dict[str, float]] = []\n    for _ in range(n):\n        s: dict[str, float] = {}\n        for comp, nominal, dist in zip(comps, nominals, dists, strict=False):\n            s[_label(comp)] = dist.sample(nominal, rnd)\n        samples.append(s)\n\n    def _run_one(sample: dict[str, float]) -&gt; AnalysisResult:\n        c_copy: Circuit = copy.deepcopy(circuit)\n        comp_list = getattr(c_copy, \"components\", None)\n        if comp_list is None:\n            comp_list = getattr(c_copy, \"_components\", [])\n        by_label: dict[str, Component] = {_label(c): c for c in comp_list}\n        for k, v in sample.items():\n            by_label[k].value = v\n        analysis = analysis_factory()\n        return analysis.run(c_copy)\n\n    # Progress handler (optional)\n    printer = None\n\n    def _notify(done: int, total: int) -&gt; None:\n        if progress is None:\n            return\n        if callable(progress):\n            try:\n                progress(done, total)\n            except Exception:\n                pass\n            return\n        # simple stderr bar\n        nonlocal printer\n        if progress is True:\n            # lazy-init\n            class _Bar:\n                def __init__(self, total: int) -&gt; None:\n                    self.total = total\n                    self.last = -1\n\n                def update(self, done: int) -&gt; None:\n                    if done == self.last:\n                        return\n                    pct = int(round(100.0 * done / max(self.total, 1)))\n                    sys.stderr.write(f\"\\rMC: {done}/{self.total} ({pct}%)\")\n                    sys.stderr.flush()\n                    self.last = done\n\n                def close(self) -&gt; None:\n                    sys.stderr.write(\"\\n\")\n\n            if printer is None:\n                printer = _Bar(total)\n            printer.update(done)\n\n    runs: list[AnalysisResult] = []\n    if workers &lt;= 1:\n        for i, s in enumerate(samples, start=1):\n            runs.append(_run_one(s))\n            _notify(i, len(samples))\n    else:\n        # Executa em paralelo preservando a ordem dos samples\n        runs_buf: list[AnalysisResult | None] = [None] * len(samples)\n        with ThreadPoolExecutor(max_workers=workers) as ex:\n            fut_to_idx = {}\n            for idx, s in enumerate(samples):\n                fut = ex.submit(_run_one, s)\n                fut_to_idx[fut] = idx\n            done = 0\n            for f in as_completed(list(fut_to_idx.keys())):\n                idx = fut_to_idx[f]\n                runs_buf[idx] = f.result()\n                done += 1\n                _notify(done, len(samples))\n        runs = [r for r in runs_buf if r is not None]\n\n    if isinstance(progress, bool) and progress and printer is not None:\n        try:\n            printer.close()\n        except Exception:\n            pass\n\n    # build optional manifest: list of (label, nominal, dist_repr)\n    manifest: list[tuple[str, float, str]] = []\n    for c, nom, d in zip(comps, nominals, dists, strict=False):\n        try:\n            d_repr = repr(d)\n        except Exception:\n            d_repr = type(d).__name__\n        manifest.append((_label(c), nom, d_repr))\n\n    return MonteCarloResult(samples=samples, runs=runs, mapping_manifest=manifest)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.overshoot","title":"<code>overshoot(ts, y_name)</code>","text":"<p>Overshoot relativo ao degrau: (Vmax - Vfinal) / (Vfinal - Vinicial).</p> Source code in <code>spicelab/analysis/metrics_tran.py</code> <pre><code>def overshoot(ts: TraceSet, y_name: str) -&gt; OvershootResult:\n    \"\"\"\n    Overshoot relativo ao degrau: (Vmax - Vfinal) / (Vfinal - Vinicial).\n    \"\"\"\n    x, y = _get_xy(ts, y_name)\n    _ = x  # reservado para futuros usos\n    n = y.shape[0]\n    if n &lt; 2:\n        return OvershootResult(\n            overshoot=0.0,\n            y_final=float(y[-1]),\n            y_initial=float(y[0]),\n            y_peak=float(y[0]),\n        )\n    y0 = float(y[0])\n    yf = float(y[-1])\n    yp = float(np.max(y))\n    denom = yf - y0\n    if np.isclose(denom, 0.0):\n        return OvershootResult(overshoot=0.0, y_final=yf, y_initial=y0, y_peak=yp)\n    ov = max(0.0, (yp - yf) / denom)\n    return OvershootResult(overshoot=ov, y_final=yf, y_initial=y0, y_peak=yp)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.overshoot_pct","title":"<code>overshoot_pct(ts, y_name)</code>","text":"<p>Overshoot em % relativo ao degrau.</p> Source code in <code>spicelab/analysis/metrics_basic.py</code> <pre><code>def overshoot_pct(ts: TraceSet, y_name: str) -&gt; float:\n    \"\"\"Overshoot em % relativo ao degrau.\"\"\"\n    return float(_ov(ts, y_name).overshoot * 100.0)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.phase_crossover_freq","title":"<code>phase_crossover_freq(ts, y_out, y_in=None, target_deg=-180.0)</code>","text":"<p>Frequ\u00eancia em que fase cruza target (padr\u00e3o: -180\u00b0).</p> Source code in <code>spicelab/analysis/metrics_ac.py</code> <pre><code>def phase_crossover_freq(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str | None = None,\n    target_deg: float = -180.0,\n) -&gt; float | None:\n    \"\"\"Frequ\u00eancia em que fase cruza target (padr\u00e3o: -180\u00b0).\"\"\"\n    f, _, ph_deg = ac_gain_phase(ts, y_out=y_out, y_in=y_in)\n    y = ph_deg - target_deg\n    s = np.sign(y)\n    idx = np.where((s[:-1] &gt;= 0) &amp; (s[1:] &lt;= 0) | (s[:-1] &lt;= 0) &amp; (s[1:] &gt;= 0))[0]\n    if idx.size == 0:\n        return None\n    i = int(idx[0])\n    x0, x1 = f[i], f[i + 1]\n    y0, y1 = y[i], y[i + 1]\n    if np.isclose(y1, y0):\n        return float(x0)\n    w = (0.0 - y0) / (y1 - y0)\n    return float(x0 + w * (x1 - x0))\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.phase_margin","title":"<code>phase_margin(ts, y_out, y_in=None)</code>","text":"<p>PM = 180\u00b0 + fase em w_c (onde |G|=1). Fase normalizada para (-180, 180].</p> <p>Fallback: se a fase aparenta estar ausente (vari\u00e2ncia ~ zero), estima PM assumindo um sistema de 1 polo m\u00ednimo-fase: \u03c6(w) \u2248 -atan(w/wp) e PM \u2248 180\u00b0 - atan(wc/wp), onde wp \u00e9 obtido via largura de banda de -3 dB.</p> Source code in <code>spicelab/analysis/metrics_ac.py</code> <pre><code>def phase_margin(\n    ts: TraceSet,\n    y_out: str,\n    y_in: str | None = None,\n) -&gt; float | None:\n    \"\"\"\n    PM = 180\u00b0 + fase em w_c (onde |G|=1). Fase normalizada para (-180, 180].\n\n    Fallback: se a fase aparenta estar ausente (vari\u00e2ncia ~ zero), estima PM assumindo\n    um sistema de 1 polo m\u00ednimo-fase: \u03c6(w) \u2248 -atan(w/wp) e PM \u2248 180\u00b0 - atan(wc/wp),\n    onde wp \u00e9 obtido via largura de banda de -3 dB.\n    \"\"\"\n    wc = crossover_freq_0db(ts, y_out=y_out, y_in=y_in)\n    if wc is None:\n        return None\n    f, _, ph = ac_gain_phase(ts, y_out=y_out, y_in=y_in)\n\n    # se h\u00e1 fase, use-a\n    if np.nanstd(ph) &gt; 1e-3:\n        phi = _interp_at_x(f, ph, wc)\n        return 180.0 + float(phi)\n\n    # fallback 1-polo: usa -3 dB para estimar wp\n    bw = bandwidth_3db(ts, y_out=y_out, y_in=y_in)\n    if bw is None or bw &lt;= 0.0:\n        # sem alternativa: devolve 180 para n\u00e3o explodir\n        return 180.0\n    phi_est = -np.degrees(np.arctan(wc / bw))\n    return 180.0 + float(phi_est)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.rise_time","title":"<code>rise_time(ts, y_name, frac_low=0.1, frac_high=0.9)</code>","text":"<p>Tempo 10\u201390% (por padr\u00e3o). Retorna RiseFall com .trise (e .tfall=None).</p> Estrat\u00e9gia robusta <p>1) Prioriza n\u00edveis com base em y0\u2192yf (degrau observado). Se n\u00e3o subir, usa span global. 2) Tenta cruzamento linear; se falhar, interpola no envelope; se falhar, usa fallback    discreto (primeiro \u00edndice com y &gt;= n\u00edvel).</p> Source code in <code>spicelab/analysis/metrics_tran.py</code> <pre><code>def rise_time(\n    ts: TraceSet,\n    y_name: str,\n    frac_low: float = 0.1,\n    frac_high: float = 0.9,\n) -&gt; RiseFall:\n    \"\"\"\n    Tempo 10\u201390% (por padr\u00e3o). Retorna RiseFall com .trise (e .tfall=None).\n\n    Estrat\u00e9gia robusta:\n      1) Prioriza n\u00edveis com base em y0\u2192yf (degrau observado). Se n\u00e3o subir, usa span global.\n      2) Tenta cruzamento linear; se falhar, interpola no envelope; se falhar, usa fallback\n         discreto (primeiro \u00edndice com y &gt;= n\u00edvel).\n    \"\"\"\n    x, y = _get_xy(ts, y_name)\n    y0 = float(y[0])\n    yf = float(y[-1])\n    y_min = float(np.min(y))\n    y_max = float(np.max(y))\n    span_end = yf - y0\n    span_global = y_max - y_min\n\n    if span_end &gt; 1e-15:\n        lo = y0 + frac_low * span_end\n        hi = y0 + frac_high * span_end\n    elif span_global &gt; 1e-15:\n        lo = y_min + frac_low * span_global\n        hi = y_min + frac_high * span_global\n    else:\n        return RiseFall(trise=None, tfall=None)\n\n    # 1) cruzamento linear\n    t_lo = _cross_time(x, y, lo)\n    t_hi = _cross_time(x, y, hi)\n\n    # 2) envelope (n\u00e3o-decrescente)\n    if t_lo is None:\n        t_lo = _interp_time_rise(x, y, lo)\n    if t_hi is None:\n        t_hi = _interp_time_rise(x, y, hi)\n\n    # 3) discreto (primeiro \u00edndice com y &gt;= n\u00edvel)\n    if t_lo is None:\n        t_lo = _discrete_time_first_at_or_above(x, y, lo)\n    if t_hi is None:\n        t_hi = _discrete_time_first_at_or_above(x, y, hi)\n\n    if t_lo is None or t_hi is None:\n        return RiseFall(trise=None, tfall=None)\n\n    dt = float(t_hi - t_lo)\n    if dt &lt; 0.0:\n        dt = 0.0\n    return RiseFall(trise=dt, tfall=None)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.run_ac","title":"<code>run_ac(circuit, sweep_type, n, fstart, fstop, *, return_df=False)</code>","text":"<p>Run an AC analysis and optionally return a DataFrame of traces.</p> Source code in <code>spicelab/analysis/__init__.py</code> <pre><code>def run_ac(\n    circuit: Circuit,\n    sweep_type: str,\n    n: int,\n    fstart: float,\n    fstop: float,\n    *,\n    return_df: bool = False,\n) -&gt; AnalysisResult | Any:\n    \"\"\"Run an AC analysis and optionally return a DataFrame of traces.\"\"\"\n    res = AC(sweep_type, n, fstart, fstop).run(circuit)\n    if return_df:\n        return res.traces.to_dataframe()\n    return res\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.run_op","title":"<code>run_op(circuit)</code>","text":"<p>Run a simple .OP analysis and return the AnalysisResult.</p> Example <p>from spicelab.core.circuit import Circuit from spicelab.core.components import Vdc, Resistor from spicelab.core.net import GND c = Circuit(\"rc\") V1, R1 = Vdc(\"1\", 5.0), Resistor(\"1\", \"1k\") c.add(V1, R1) c.connect(V1.ports[0], R1.ports[0]) c.connect(R1.ports[1], GND) c.connect(V1.ports[1], GND) _ = run_op(c)  # doctest: +SKIP</p> Source code in <code>spicelab/analysis/__init__.py</code> <pre><code>def run_op(circuit: Circuit) -&gt; AnalysisResult:\n    \"\"\"Run a simple .OP analysis and return the AnalysisResult.\n\n    Example:\n        &gt;&gt;&gt; from spicelab.core.circuit import Circuit\n        &gt;&gt;&gt; from spicelab.core.components import Vdc, Resistor\n        &gt;&gt;&gt; from spicelab.core.net import GND\n        &gt;&gt;&gt; c = Circuit(\"rc\")\n        &gt;&gt;&gt; V1, R1 = Vdc(\"1\", 5.0), Resistor(\"1\", \"1k\")\n        &gt;&gt;&gt; c.add(V1, R1)\n        &gt;&gt;&gt; c.connect(V1.ports[0], R1.ports[0])\n        &gt;&gt;&gt; c.connect(R1.ports[1], GND)\n        &gt;&gt;&gt; c.connect(V1.ports[1], GND)\n        &gt;&gt;&gt; _ = run_op(c)  # doctest: +SKIP\n    \"\"\"\n    return OP().run(circuit)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.run_step_native","title":"<code>run_step_native(circuit, directives)</code>","text":"<p>Roda um deck com diretivas .step nativas (j\u00e1 contidas em <code>directives</code>) e retorna todos os plots como lista de TraceSet.</p> Source code in <code>spicelab/analysis/step_native.py</code> <pre><code>def run_step_native(circuit: Circuit, directives: list[str]) -&gt; StepNativeResult:\n    \"\"\"\n    Roda um deck com diretivas .step nativas (j\u00e1 contidas em `directives`)\n    e retorna todos os plots como lista de TraceSet.\n    \"\"\"\n    net = circuit.build_netlist()\n    run_directives = get_run_directives()\n    res = run_directives(net, directives)\n    if res.returncode != 0 or not res.artifacts.raw_path:\n        raise RuntimeError(\"NGSpice failed for native .step run\")\n    sets = parse_ngspice_ascii_raw_multi(res.artifacts.raw_path)\n    return StepNativeResult(tracesets=sets)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.run_tran","title":"<code>run_tran(circuit, tstep, tstop, tstart=None, *, return_df=False)</code>","text":"<p>Run a transient (.TRAN) analysis and optionally return a Pandas DataFrame.</p> <ul> <li>return_df=False returns AnalysisResult</li> <li>return_df=True returns a DataFrame via TraceSet.to_dataframe()</li> </ul> Source code in <code>spicelab/analysis/__init__.py</code> <pre><code>def run_tran(\n    circuit: Circuit,\n    tstep: str,\n    tstop: str,\n    tstart: str | None = None,\n    *,\n    return_df: bool = False,\n) -&gt; AnalysisResult | Any:\n    \"\"\"Run a transient (.TRAN) analysis and optionally return a Pandas DataFrame.\n\n    - return_df=False returns AnalysisResult\n    - return_df=True returns a DataFrame via TraceSet.to_dataframe()\n    \"\"\"\n    res = TRAN(tstep, tstop, tstart).run(circuit)\n    if return_df:\n        return res.traces.to_dataframe()\n    return res\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.settling_time","title":"<code>settling_time(ts, y_name, tol=0.02)</code>","text":"<p>Primeiro instante em que |y(t) - y_final| &lt;= tol*|y_final - y_initial| e permanece assim at\u00e9 o final.</p> Source code in <code>spicelab/analysis/metrics_tran.py</code> <pre><code>def settling_time(ts: TraceSet, y_name: str, tol: float = 0.02) -&gt; SettlingResult:\n    \"\"\"\n    Primeiro instante em que |y(t) - y_final| &lt;= tol*|y_final - y_initial|\n    e permanece assim at\u00e9 o final.\n    \"\"\"\n    x, y = _get_xy(ts, y_name)\n    y0 = float(y[0])\n    yf = float(y[-1])\n    band = abs(tol * (yf - y0))\n    if band == 0.0:\n        return SettlingResult(t_settle=None, idx=None, band=band, y_final=yf)\n\n    err = np.abs(y - yf)\n    inside = err &lt;= band\n    suffix_ok = np.flip(np.cumsum(np.flip(~inside)) == 0)\n    ok = inside &amp; suffix_ok\n    idxs = np.where(ok)[0]\n    if idxs.size == 0:\n        return SettlingResult(t_settle=None, idx=None, band=band, y_final=yf)\n    i = int(idxs[0])\n    return SettlingResult(t_settle=float(x[i]), idx=i, band=band, y_final=yf)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.stack_runs_to_df","title":"<code>stack_runs_to_df(runs, params_list=None, y=None, with_x=True, run_index_name='run_idx')</code>","text":"<p>Empilha uma lista de <code>AnalysisResult</code> em um \u00fanico DataFrame, adicionando as colunas de par\u00e2metros (<code>params_list[i]</code>) por run.</p> <ul> <li><code>y</code>: lista de nomes de tra\u00e7os a manter (ex.: [\"v(out)\"]). Se None, mant\u00e9m todos.</li> <li><code>with_x</code>: inclui a coluna do eixo X (primeira coluna do TraceSet), tipicamente \"time\"/\"frequency\".</li> </ul> Source code in <code>spicelab/analysis/post.py</code> <pre><code>def stack_runs_to_df(\n    runs: Sequence[AnalysisResult],\n    params_list: Sequence[Mapping[str, str | float]] | None = None,\n    y: Sequence[str] | None = None,\n    with_x: bool = True,\n    run_index_name: str = \"run_idx\",\n) -&gt; Any:\n    \"\"\"\n    Empilha uma lista de `AnalysisResult` em um \u00fanico DataFrame, adicionando\n    as colunas de par\u00e2metros (`params_list[i]`) por run.\n\n    - `y`: lista de nomes de tra\u00e7os a manter (ex.: [\"v(out)\"]). Se None, mant\u00e9m todos.\n    - `with_x`: inclui a coluna do eixo X (primeira coluna do TraceSet), tipicamente\n    \"time\"/\"frequency\".\n    \"\"\"\n    pd = _ensure_pandas()\n    frames: list[Any] = []\n    for i, res in enumerate(runs):\n        df = res.traces.to_dataframe()\n        x_name = res.traces.x.name\n        keep = list(df.columns)\n        if y is not None:\n            keep = [x_name] + list(y) if with_x else list(y)\n            df = _pick_columns(df, keep)\n        else:\n            if not with_x:\n                keep = [c for c in keep if c != x_name]\n                df = df[keep]\n        # par\u00e2metros deste run\n        params = params_list[i] if params_list is not None else {}\n        for k, v in params.items():\n            df[k] = v\n        df[run_index_name] = i\n        frames.append(df)\n    if not frames:\n        return pd.DataFrame()\n    return pd.concat(frames, ignore_index=True)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.stack_step_to_df","title":"<code>stack_step_to_df(step, y=None, with_x=True, run_index_name='run_idx')</code>","text":"<p>Vers\u00e3o pr\u00e1tica para <code>StepResult</code>: empilha <code>step.runs</code> com as colunas de <code>step.grid</code>.</p> Source code in <code>spicelab/analysis/post.py</code> <pre><code>def stack_step_to_df(\n    step: StepResult,\n    y: Sequence[str] | None = None,\n    with_x: bool = True,\n    run_index_name: str = \"run_idx\",\n) -&gt; Any:\n    \"\"\"\n    Vers\u00e3o pr\u00e1tica para `StepResult`: empilha `step.runs` com as colunas de `step.grid`.\n    \"\"\"\n    return stack_runs_to_df(step.runs, step.grid, y=y, with_x=with_x, run_index_name=run_index_name)\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.sweep_component","title":"<code>sweep_component(circuit, component, values, analysis_factory, param_name=None, *, progress=None)</code>","text":"<p>Executa v\u00e1rias simula\u00e7\u00f5es alterando <code>component.value</code> em Python.</p> <ul> <li><code>values</code>: lista de valores a aplicar no componente (ex.: [\"1k\",\"2k\",\"5k\"])</li> <li><code>analysis_factory</code>: callable que cria uma inst\u00e2ncia da an\u00e1lise a cada itera\u00e7\u00e3o,   por ex.: <code>lambda: TRAN(\"100us\",\"1ms\")</code> ou <code>lambda: OP()</code></li> <li><code>param_name</code>: opcional, nome amig\u00e1vel para registrar no resultado</li> </ul> Source code in <code>spicelab/analysis/sweep.py</code> <pre><code>def sweep_component(\n    circuit: Circuit,\n    component: Component,\n    values: Sequence[str | float],\n    analysis_factory: Callable[[], A],\n    param_name: str | None = None,\n    *,\n    progress: bool | Callable[[int, int], None] | None = None,\n) -&gt; SweepResult:\n    \"\"\"Executa v\u00e1rias simula\u00e7\u00f5es alterando `component.value` em Python.\n\n    - `values`: lista de valores a aplicar no componente (ex.: [\"1k\",\"2k\",\"5k\"])\n    - `analysis_factory`: callable que cria uma inst\u00e2ncia da an\u00e1lise a cada itera\u00e7\u00e3o,\n      por ex.: `lambda: TRAN(\"100us\",\"1ms\")` ou `lambda: OP()`\n    - `param_name`: opcional, nome amig\u00e1vel para registrar no resultado\n    \"\"\"\n    original = component.value\n\n    def _notify(done: int) -&gt; None:\n        if not progress:\n            return\n        if callable(progress):\n            try:\n                progress(done, len(values))\n            except Exception:\n                pass\n            return\n        pct = int(round(100.0 * done / max(len(values), 1)))\n        sys.stderr.write(f\"\\rSWEEP[{component.ref}]: {done}/{len(values)} ({pct}%)\")\n        sys.stderr.flush()\n\n    runs: list[AnalysisResult] = []\n    try:\n        for i, v in enumerate(values, start=1):\n            component.value = v\n            analysis = analysis_factory()\n            res = analysis.run(circuit)  # type: ignore[attr-defined]\n            runs.append(res)\n            _notify(i)\n    finally:\n        component.value = original  # restore\n    return SweepResult(\n        param_name or f\"{type(component).__name__}.{component.ref}\", list(values), runs\n    )\n</code></pre>"},{"location":"reference/analysis/#spicelab.analysis.worst_case","title":"<code>worst_case(circuit, analysis_factory, metric, space, mode='min', n_random=64, n_refine=3, progress=None)</code>","text":"<p>Busca pior caso sobre par\u00e2metros .param discretizados em 'space'. Estrat\u00e9gia: amostragem aleat\u00f3ria inicial -&gt; refinamento coordenado local.</p> Source code in <code>spicelab/analysis/worstcase.py</code> <pre><code>def worst_case(\n    circuit: Circuit,\n    analysis_factory: Callable[[], object],\n    metric: Callable[[AnalysisResult], float],\n    space: Mapping[str, Sequence[float | str]],\n    mode: str = \"min\",  # \"min\" or \"max\"\n    n_random: int = 64,\n    n_refine: int = 3,\n    progress: bool | Callable[[int, int], None] | None = None,\n) -&gt; WorstCaseResult:\n    \"\"\"\n    Busca pior caso sobre par\u00e2metros .param discretizados em 'space'.\n    Estrat\u00e9gia: amostragem aleat\u00f3ria inicial -&gt; refinamento coordenado local.\n    \"\"\"\n    net = circuit.build_netlist()\n    base = analysis_factory()._directives()  # type: ignore[attr-defined]\n\n    # 1) random\n    total = n_random + sum(len(space[k]) for k in space) * n_refine\n\n    def _notify(done: int) -&gt; None:\n        if not progress:\n            return\n        if callable(progress):\n            try:\n                progress(done, total)\n            except Exception:\n                pass\n            return\n        pct = int(round(100.0 * done / max(total, 1)))\n        sys.stderr.write(f\"\\rWORST: {done}/{total} ({pct}%)\")\n        sys.stderr.flush()\n\n    hist: list[tuple[dict[str, float | str], float]] = []\n    best_p: dict[str, float | str] = {}\n    best_v = math.inf if mode == \"min\" else -math.inf\n\n    keys = list(space.keys())\n    choices = [list(space[k]) for k in keys]\n\n    done = 0\n    for _ in range(n_random):\n        p = {k: random.choice(choices[i]) for i, k in enumerate(keys)}\n        res = _run_with_params(net, _directives_with_params(base, p))\n        val = metric(res)\n        hist.append((p, val))\n        if (mode == \"min\" and val &lt; best_v) or (mode == \"max\" and val &gt; best_v):\n            best_p, best_v = p, val\n        done += 1\n        _notify(done)\n\n    # 2) refinamento coordenado\n    for _ in range(n_refine):\n        improved = False\n        for i, k in enumerate(keys):\n            cand: list[tuple[float, dict[str, float | str]]] = []\n            for v in choices[i]:\n                p2 = dict(best_p)\n                p2[k] = v\n                res = _run_with_params(net, _directives_with_params(base, p2))\n                val = metric(res)\n                hist.append((p2, val))\n                cand.append((val, p2))\n                done += 1\n                _notify(done)\n            if mode == \"min\":\n                val, p_sel = min(cand, key=lambda x: x[0])\n                if val &lt; best_v:\n                    best_v, best_p, improved = val, p_sel, True\n            else:\n                val, p_sel = max(cand, key=lambda x: x[0])\n                if val &gt; best_v:\n                    best_v, best_p, improved = val, p_sel, True\n        if not improved:\n            break\n\n    return WorstCaseResult(best_params=best_p, best_value=best_v, history=hist)\n</code></pre>"},{"location":"reference/core/","title":"Core","text":""},{"location":"reference/core/#spicelab.core.Capacitor","title":"<code>Capacitor</code>","text":"<p>               Bases: <code>Component</code></p> <p>Capacitor de 2 terminais; portas: a (positivo), b (negativo).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Capacitor(Component):\n    \"\"\"Capacitor de 2 terminais; portas: a (positivo), b (negativo).\"\"\"\n\n    def __init__(self, ref: str, value: str | float = \"\") -&gt; None:\n        super().__init__(ref=ref, value=value)\n        self._ports = (Port(self, \"a\", PortRole.POSITIVE), Port(self, \"b\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        a, b = self.ports\n        return f\"C{self.ref} {net_of(a)} {net_of(b)} {self.value}\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit","title":"<code>Circuit</code>  <code>dataclass</code>","text":"<p>Logical circuit composed of components, nets and raw SPICE directives.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>@dataclass\nclass Circuit:\n    \"\"\"Logical circuit composed of components, nets and raw SPICE directives.\"\"\"\n\n    name: str\n    _net_ids: dict[Net, int] = field(default_factory=dict, init=False)\n    _port_to_net: dict[Port, Net] = field(default_factory=dict, init=False)\n    _components: list[Component] = field(default_factory=list, init=False)\n    _directives: list[str] = field(default_factory=list, init=False)\n    # metadata captured when loading from existing netlists\n    _subckt_defs: dict[str, str] = field(default_factory=dict, init=False)\n    _subckt_instances: list[dict[str, object]] = field(default_factory=list, init=False)\n\n    # ----------------------------------------------------------------------------------\n    # Building blocks\n    # ----------------------------------------------------------------------------------\n    def add(self, *components: Component) -&gt; Circuit:\n        \"\"\"Append one or more components to the circuit.\"\"\"\n\n        self._components.extend(components)\n        return self\n\n    def add_directive(self, line: str) -&gt; Circuit:\n        \"\"\"Append a raw SPICE directive (``.model``, ``.param`` ...).\"\"\"\n\n        self._directives.append(line.rstrip(\"\\n\"))\n        return self\n\n    def add_directive_once(self, line: str) -&gt; Circuit:\n        \"\"\"Add a directive if an identical line (ignoring whitespace) is absent.\"\"\"\n\n        normalized = line.strip()\n        for existing in self._directives:\n            if existing.strip() == normalized:\n                return self\n        return self.add_directive(line)\n\n    def connect(self, a: Port, b: Net | Port) -&gt; Circuit:\n        \"\"\"Connect a port to another port or to a logical net.\"\"\"\n\n        if isinstance(b, Port):\n            net_a = self._port_to_net.get(a)\n            net_b = self._port_to_net.get(b)\n            if net_a and net_b and net_a is not net_b:\n                # merge: remap every port previously associated with net_b to net_a\n                for port, current in list(self._port_to_net.items()):\n                    if current is net_b:\n                        self._port_to_net[port] = net_a\n            else:\n                shared = net_a or net_b or Net()\n                self._port_to_net[a] = shared\n                self._port_to_net[b] = shared\n        else:\n            self._port_to_net[a] = b\n        return self\n\n    # ----------------------------------------------------------------------------------\n    # Net handling\n    # ----------------------------------------------------------------------------------\n    def _assign_node_ids(self) -&gt; None:\n        self._net_ids.clear()\n        self._net_ids[GND] = 0\n\n        next_id = 1\n        seen: set[Net] = {GND}\n\n        def nets_from_components() -&gt; Iterable[Net]:\n            for comp in self._components:\n                for port in comp.ports:\n                    net = self._port_to_net.get(port)\n                    if net is not None:\n                        yield net\n\n        for net in nets_from_components():\n            if net in seen:\n                continue\n            seen.add(net)\n            if getattr(net, \"name\", None) and net.name != \"0\":\n                # preserve named nets but still assign an id for bookkeeping\n                self._net_ids[net] = next_id\n            else:\n                self._net_ids[net] = next_id\n            next_id += 1\n\n    def _net_of(self, port: Port) -&gt; str:\n        net = self._port_to_net.get(port)\n        if net is None:\n            raise ValueError(f\"Unconnected port: {port.owner.ref}.{port.name}\")\n\n        if net is GND or getattr(net, \"name\", None) == \"0\":\n            return \"0\"\n\n        if getattr(net, \"name\", None):\n            return str(net.name)\n\n        node_id = self._net_ids.get(net)\n        if node_id is None:\n            raise RuntimeError(\"Node IDs not assigned\")\n        return str(node_id)\n\n    # ----------------------------------------------------------------------------------\n    # Netlist helpers\n    # ----------------------------------------------------------------------------------\n    def build_netlist(self) -&gt; str:\n        \"\"\"Return a SPICE netlist representation of this circuit.\"\"\"\n\n        self._assign_node_ids()\n\n        lines: list[str] = [f\"* {self.name}\"]\n\n        for comp in self._components:\n            card = comp.spice_card(self._net_of)\n            # components such as AnalogMux may emit multi-line cards\n            for ln in card.splitlines():\n                if ln.strip():\n                    lines.append(ln)\n\n        for directive in self._directives:\n            lines.extend(directive.splitlines())\n\n        if not any(line.strip().lower() == \".end\" for line in lines):\n            lines.append(\".end\")\n\n        return \"\\n\".join(lines) + \"\\n\"\n\n    def save_netlist(self, path: str | Path) -&gt; Path:\n        \"\"\"Persist the netlist to ``path`` and return the resolved ``Path``.\"\"\"\n\n        p = Path(path)\n        p.write_text(self.build_netlist(), encoding=\"utf-8\")\n        return p\n\n    # ----------------------------------------------------------------------------------\n    # Introspection helpers\n    # ----------------------------------------------------------------------------------\n    def _net_label(self, net: Net | None) -&gt; str:\n        if net is None:\n            return \"&lt;unconnected&gt;\"\n        if net is GND or getattr(net, \"name\", None) == \"0\":\n            return \"0\"\n        if getattr(net, \"name\", None):\n            return str(net.name)\n        node_id = self._net_ids.get(net)\n        if node_id is None:\n            self._assign_node_ids()\n            node_id = self._net_ids.get(net)\n        return f\"N{node_id:03d}\" if node_id is not None else \"&lt;unnamed&gt;\"\n\n    def summary(self) -&gt; str:\n        \"\"\"Return a human-readable summary of the circuit and connectivity.\"\"\"\n\n        self._assign_node_ids()\n\n        lines: list[str] = []\n        warnings: list[str] = []\n\n        lines.append(f\"Circuit: {self.name}\")\n        lines.append(f\"Components ({len(self._components)}):\")\n\n        for comp in self._components:\n            port_descriptions: list[str] = []\n            for port in comp.ports:\n                net = self._port_to_net.get(port)\n                label = self._net_label(net)\n                if label == \"&lt;unconnected&gt;\":\n                    warnings.append(f\"Port {comp.ref}.{port.name} is unconnected\")\n                port_descriptions.append(f\"{port.name}-&gt;{label}\")\n            port_info = \", \".join(port_descriptions) if port_descriptions else \"&lt;no ports&gt;\"\n            lines.append(f\"  - {comp.ref} ({type(comp).__name__}): {port_info}\")\n\n        net_names = sorted({self._net_label(net) for net in self._port_to_net.values() if net})\n        if net_names:\n            lines.append(f\"Nets ({len(net_names)}): {', '.join(net_names)}\")\n\n        if warnings:\n            lines.append(\"Warnings:\")\n            for msg in warnings:\n                lines.append(f\"  * {msg}\")\n        else:\n            lines.append(\"Warnings: none\")\n\n        return \"\\n\".join(lines)\n\n    def to_dot(self) -&gt; str:\n        \"\"\"Return a Graphviz DOT representation of the circuit.\"\"\"\n\n        self._assign_node_ids()\n\n        lines: list[str] = [\"graph circuit {\", \"  rankdir=LR;\"]\n\n        comp_ids: dict[Component, str] = {}\n        for idx, comp in enumerate(self._components, start=1):\n            comp_id = f\"comp_{idx}\"\n            comp_ids[comp] = comp_id\n            label = f\"{comp.ref}\\\\n{type(comp).__name__}\"\n            lines.append(f'  \"{comp_id}\" [shape=box,label=\"{label}\"];')\n\n        net_ids: dict[Net | None, str] = {}\n        net_counter = 1\n\n        def _net_node(net: Net | None) -&gt; str:\n            nonlocal net_counter\n            if net in net_ids:\n                return net_ids[net]\n            node_id = f\"net_{net_counter}\"\n            net_counter += 1\n            label = self._net_label(net)\n            shape = \"ellipse\" if label != \"&lt;unconnected&gt;\" else \"point\"\n            net_ids[net] = node_id\n            lines.append(f'  \"{node_id}\" [shape={shape},label=\"{label}\"];')\n            return node_id\n\n        for comp in self._components:\n            comp_id = comp_ids[comp]\n            for port in comp.ports:\n                net = self._port_to_net.get(port)\n                net_id = _net_node(net)\n                lines.append(f'  \"{comp_id}\" -- \"{net_id}\" [label=\"{port.name}\",fontsize=10];')\n\n        lines.append(\"}\")\n        return \"\\n\".join(lines)\n\n    # ----------------------------------------------------------------------------------\n    # Netlist import\n    # ----------------------------------------------------------------------------------\n    @classmethod\n    def from_netlist(cls, path: str | Path) -&gt; Circuit:\n        \"\"\"Load a circuit from a plain SPICE netlist file.\"\"\"\n\n        p = Path(path)\n        text = p.read_text(encoding=\"utf-8\")\n\n        from spicelab.io.spice_parser import parse_lines_to_ast, preprocess_netlist\n\n        lines = preprocess_netlist(text)\n        ast = parse_lines_to_ast(lines)\n\n        name = p.stem\n        if lines and lines[0].lstrip().startswith(\"*\"):\n            maybe_title = lines[0].lstrip()[1:].strip()\n            if maybe_title:\n                name = maybe_title\n\n        circ = cls(name=name)\n\n        for node in ast:\n            kind_obj = node.get(\"type\")\n            kind = str(kind_obj) if isinstance(kind_obj, str) else None\n            raw_obj = node.get(\"raw\")\n            raw = str(raw_obj) if isinstance(raw_obj, str) else \"\"\n\n            if kind == \"subckt\":\n                header = raw.splitlines()[0]\n                parts = header.split()\n                if len(parts) &gt;= 2:\n                    circ._subckt_defs[parts[1]] = raw\n                circ.add_directive(raw)\n                continue\n\n            if kind == \"comment\" or kind == \"directive\":\n                circ.add_directive(raw)\n                continue\n\n            if kind != \"component\":\n                continue\n\n            tokens_obj = node.get(\"tokens\")\n            tokens: list[str] = [str(t) for t in tokens_obj] if isinstance(tokens_obj, list) else []\n            if not tokens:\n                continue\n\n            card = tokens[0]\n            letter = cast(str | None, node.get(\"letter\"))\n            ref = cast(str | None, node.get(\"ref\"))\n\n            try:\n                comp = cls._component_from_tokens(letter, ref, tokens)\n                if comp is None:\n                    circ.add_directive(raw)\n                    continue\n                circ.add(comp)\n                circ._connect_from_tokens(comp, tokens[1:])\n                if letter == \"X\":\n                    circ._subckt_instances.append(\n                        {\"inst\": card, \"subckt\": tokens[-1], \"tokens\": tokens}\n                    )\n            except Exception as exc:  # pragma: no cover - defensive fallback\n                log.warning(\"Failed to parse component '%s': %s\", card, exc)\n                circ.add_directive(raw)\n\n        return circ\n\n    # ----------------------------------------------------------------------------------\n    # Helpers for from_netlist\n    # ----------------------------------------------------------------------------------\n    @staticmethod\n    def _component_from_tokens(\n        letter: str | None, ref: str | None, tokens: list[str]\n    ) -&gt; Component | None:\n        if not letter or not ref:\n            return None\n\n        letter = letter.upper()\n        value = \" \".join(tokens[3:]) if len(tokens) &gt; 3 else \"\"\n\n        if letter == \"R\":\n            return Resistor(ref=ref, value=value)\n        if letter == \"C\":\n            return Capacitor(ref=ref, value=value)\n        if letter == \"L\":\n            return Inductor(ref=ref, value=value)\n        if letter == \"V\":\n            return Vdc(ref=ref, value=value)\n        if letter == \"I\":\n            return Idc(ref=ref, value=value)\n        if letter == \"E\":\n            gain = \" \".join(tokens[5:]) if len(tokens) &gt; 5 else \"\"\n            return VCVS(ref=ref, gain=gain)\n        if letter == \"G\":\n            gm = \" \".join(tokens[5:]) if len(tokens) &gt; 5 else \"\"\n            return VCCS(ref=ref, gm=gm)\n        if letter == \"F\":\n            gain = \" \".join(tokens[4:]) if len(tokens) &gt; 4 else \"\"\n            ctrl = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return CCCS(ref=ref, ctrl_vsrc=ctrl, gain=gain)\n        if letter == \"H\":\n            r = \" \".join(tokens[4:]) if len(tokens) &gt; 4 else \"\"\n            ctrl = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return CCVS(ref=ref, ctrl_vsrc=ctrl, r=r)\n        if letter == \"D\":\n            model = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return Diode(ref=ref, model=model)\n        if letter == \"S\":\n            model = \" \".join(tokens[5:]) if len(tokens) &gt; 5 else \"\"\n            return VSwitch(ref=ref, model=model)\n        if letter == \"W\":\n            model = \" \".join(tokens[4:]) if len(tokens) &gt; 4 else \"\"\n            ctrl = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return ISwitch(ref=ref, ctrl_vsrc=ctrl, model=model)\n\n        # Subcircuits and unsupported devices are preserved as directives\n        return None\n\n    def _connect_from_tokens(self, component: Component, node_tokens: list[str]) -&gt; None:\n        port_iter = iter(component.ports)\n        for node_name in node_tokens:\n            try:\n                port = next(port_iter)\n            except StopIteration:\n                break\n            net = self._get_or_create_net(node_name)\n            self.connect(port, net)\n\n    def _get_or_create_net(self, name: str) -&gt; Net:\n        if name == \"0\":\n            return GND\n        for net in self._port_to_net.values():\n            if getattr(net, \"name\", None) == name:\n                return net\n        new = Net(name)\n        return new\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.add","title":"<code>add(*components)</code>","text":"<p>Append one or more components to the circuit.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def add(self, *components: Component) -&gt; Circuit:\n    \"\"\"Append one or more components to the circuit.\"\"\"\n\n    self._components.extend(components)\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.add_directive","title":"<code>add_directive(line)</code>","text":"<p>Append a raw SPICE directive (<code>.model</code>, <code>.param</code> ...).</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def add_directive(self, line: str) -&gt; Circuit:\n    \"\"\"Append a raw SPICE directive (``.model``, ``.param`` ...).\"\"\"\n\n    self._directives.append(line.rstrip(\"\\n\"))\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.add_directive_once","title":"<code>add_directive_once(line)</code>","text":"<p>Add a directive if an identical line (ignoring whitespace) is absent.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def add_directive_once(self, line: str) -&gt; Circuit:\n    \"\"\"Add a directive if an identical line (ignoring whitespace) is absent.\"\"\"\n\n    normalized = line.strip()\n    for existing in self._directives:\n        if existing.strip() == normalized:\n            return self\n    return self.add_directive(line)\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.build_netlist","title":"<code>build_netlist()</code>","text":"<p>Return a SPICE netlist representation of this circuit.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def build_netlist(self) -&gt; str:\n    \"\"\"Return a SPICE netlist representation of this circuit.\"\"\"\n\n    self._assign_node_ids()\n\n    lines: list[str] = [f\"* {self.name}\"]\n\n    for comp in self._components:\n        card = comp.spice_card(self._net_of)\n        # components such as AnalogMux may emit multi-line cards\n        for ln in card.splitlines():\n            if ln.strip():\n                lines.append(ln)\n\n    for directive in self._directives:\n        lines.extend(directive.splitlines())\n\n    if not any(line.strip().lower() == \".end\" for line in lines):\n        lines.append(\".end\")\n\n    return \"\\n\".join(lines) + \"\\n\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.connect","title":"<code>connect(a, b)</code>","text":"<p>Connect a port to another port or to a logical net.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def connect(self, a: Port, b: Net | Port) -&gt; Circuit:\n    \"\"\"Connect a port to another port or to a logical net.\"\"\"\n\n    if isinstance(b, Port):\n        net_a = self._port_to_net.get(a)\n        net_b = self._port_to_net.get(b)\n        if net_a and net_b and net_a is not net_b:\n            # merge: remap every port previously associated with net_b to net_a\n            for port, current in list(self._port_to_net.items()):\n                if current is net_b:\n                    self._port_to_net[port] = net_a\n        else:\n            shared = net_a or net_b or Net()\n            self._port_to_net[a] = shared\n            self._port_to_net[b] = shared\n    else:\n        self._port_to_net[a] = b\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.from_netlist","title":"<code>from_netlist(path)</code>  <code>classmethod</code>","text":"<p>Load a circuit from a plain SPICE netlist file.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>@classmethod\ndef from_netlist(cls, path: str | Path) -&gt; Circuit:\n    \"\"\"Load a circuit from a plain SPICE netlist file.\"\"\"\n\n    p = Path(path)\n    text = p.read_text(encoding=\"utf-8\")\n\n    from spicelab.io.spice_parser import parse_lines_to_ast, preprocess_netlist\n\n    lines = preprocess_netlist(text)\n    ast = parse_lines_to_ast(lines)\n\n    name = p.stem\n    if lines and lines[0].lstrip().startswith(\"*\"):\n        maybe_title = lines[0].lstrip()[1:].strip()\n        if maybe_title:\n            name = maybe_title\n\n    circ = cls(name=name)\n\n    for node in ast:\n        kind_obj = node.get(\"type\")\n        kind = str(kind_obj) if isinstance(kind_obj, str) else None\n        raw_obj = node.get(\"raw\")\n        raw = str(raw_obj) if isinstance(raw_obj, str) else \"\"\n\n        if kind == \"subckt\":\n            header = raw.splitlines()[0]\n            parts = header.split()\n            if len(parts) &gt;= 2:\n                circ._subckt_defs[parts[1]] = raw\n            circ.add_directive(raw)\n            continue\n\n        if kind == \"comment\" or kind == \"directive\":\n            circ.add_directive(raw)\n            continue\n\n        if kind != \"component\":\n            continue\n\n        tokens_obj = node.get(\"tokens\")\n        tokens: list[str] = [str(t) for t in tokens_obj] if isinstance(tokens_obj, list) else []\n        if not tokens:\n            continue\n\n        card = tokens[0]\n        letter = cast(str | None, node.get(\"letter\"))\n        ref = cast(str | None, node.get(\"ref\"))\n\n        try:\n            comp = cls._component_from_tokens(letter, ref, tokens)\n            if comp is None:\n                circ.add_directive(raw)\n                continue\n            circ.add(comp)\n            circ._connect_from_tokens(comp, tokens[1:])\n            if letter == \"X\":\n                circ._subckt_instances.append(\n                    {\"inst\": card, \"subckt\": tokens[-1], \"tokens\": tokens}\n                )\n        except Exception as exc:  # pragma: no cover - defensive fallback\n            log.warning(\"Failed to parse component '%s': %s\", card, exc)\n            circ.add_directive(raw)\n\n    return circ\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.save_netlist","title":"<code>save_netlist(path)</code>","text":"<p>Persist the netlist to <code>path</code> and return the resolved <code>Path</code>.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def save_netlist(self, path: str | Path) -&gt; Path:\n    \"\"\"Persist the netlist to ``path`` and return the resolved ``Path``.\"\"\"\n\n    p = Path(path)\n    p.write_text(self.build_netlist(), encoding=\"utf-8\")\n    return p\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.summary","title":"<code>summary()</code>","text":"<p>Return a human-readable summary of the circuit and connectivity.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def summary(self) -&gt; str:\n    \"\"\"Return a human-readable summary of the circuit and connectivity.\"\"\"\n\n    self._assign_node_ids()\n\n    lines: list[str] = []\n    warnings: list[str] = []\n\n    lines.append(f\"Circuit: {self.name}\")\n    lines.append(f\"Components ({len(self._components)}):\")\n\n    for comp in self._components:\n        port_descriptions: list[str] = []\n        for port in comp.ports:\n            net = self._port_to_net.get(port)\n            label = self._net_label(net)\n            if label == \"&lt;unconnected&gt;\":\n                warnings.append(f\"Port {comp.ref}.{port.name} is unconnected\")\n            port_descriptions.append(f\"{port.name}-&gt;{label}\")\n        port_info = \", \".join(port_descriptions) if port_descriptions else \"&lt;no ports&gt;\"\n        lines.append(f\"  - {comp.ref} ({type(comp).__name__}): {port_info}\")\n\n    net_names = sorted({self._net_label(net) for net in self._port_to_net.values() if net})\n    if net_names:\n        lines.append(f\"Nets ({len(net_names)}): {', '.join(net_names)}\")\n\n    if warnings:\n        lines.append(\"Warnings:\")\n        for msg in warnings:\n            lines.append(f\"  * {msg}\")\n    else:\n        lines.append(\"Warnings: none\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/#spicelab.core.Circuit.to_dot","title":"<code>to_dot()</code>","text":"<p>Return a Graphviz DOT representation of the circuit.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def to_dot(self) -&gt; str:\n    \"\"\"Return a Graphviz DOT representation of the circuit.\"\"\"\n\n    self._assign_node_ids()\n\n    lines: list[str] = [\"graph circuit {\", \"  rankdir=LR;\"]\n\n    comp_ids: dict[Component, str] = {}\n    for idx, comp in enumerate(self._components, start=1):\n        comp_id = f\"comp_{idx}\"\n        comp_ids[comp] = comp_id\n        label = f\"{comp.ref}\\\\n{type(comp).__name__}\"\n        lines.append(f'  \"{comp_id}\" [shape=box,label=\"{label}\"];')\n\n    net_ids: dict[Net | None, str] = {}\n    net_counter = 1\n\n    def _net_node(net: Net | None) -&gt; str:\n        nonlocal net_counter\n        if net in net_ids:\n            return net_ids[net]\n        node_id = f\"net_{net_counter}\"\n        net_counter += 1\n        label = self._net_label(net)\n        shape = \"ellipse\" if label != \"&lt;unconnected&gt;\" else \"point\"\n        net_ids[net] = node_id\n        lines.append(f'  \"{node_id}\" [shape={shape},label=\"{label}\"];')\n        return node_id\n\n    for comp in self._components:\n        comp_id = comp_ids[comp]\n        for port in comp.ports:\n            net = self._port_to_net.get(port)\n            net_id = _net_node(net)\n            lines.append(f'  \"{comp_id}\" -- \"{net_id}\" [label=\"{port.name}\",fontsize=10];')\n\n    lines.append(\"}\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/#spicelab.core.Inductor","title":"<code>Inductor</code>","text":"<p>               Bases: <code>Component</code></p> <p>Indutor de 2 terminais; portas: a (positivo), b (negativo).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Inductor(Component):\n    \"\"\"Indutor de 2 terminais; portas: a (positivo), b (negativo).\"\"\"\n\n    def __init__(self, ref: str, value: str | float = \"\") -&gt; None:\n        super().__init__(ref=ref, value=value)\n        self._ports = (Port(self, \"a\", PortRole.POSITIVE), Port(self, \"b\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        a, b = self.ports\n        return f\"L{self.ref} {net_of(a)} {net_of(b)} {self.value}\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Ipulse","title":"<code>Ipulse</code>","text":"<p>               Bases: <code>Component</code></p> <p>Fonte de corrente PULSE(I1 I2 TD TR TF PW PER).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Ipulse(Component):\n    \"\"\"Fonte de corrente PULSE(I1 I2 TD TR TF PW PER).\"\"\"\n\n    def __init__(\n        self,\n        ref: str,\n        i1: str | float,\n        i2: str | float,\n        td: str | float,\n        tr: str | float,\n        tf: str | float,\n        pw: str | float,\n        per: str | float,\n    ) -&gt; None:\n        super().__init__(ref=ref, value=\"\")\n        self.i1, self.i2, self.td, self.tr, self.tf, self.pw, self.per = (\n            i1,\n            i2,\n            td,\n            tr,\n            tf,\n            pw,\n            per,\n        )\n        self._ports = (Port(self, \"p\", PortRole.POSITIVE), Port(self, \"n\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        p, n = self.ports\n        return (\n            f\"I{self.ref} {net_of(p)} {net_of(n)} \"\n            f\"PULSE({self.i1} {self.i2} {self.td} {self.tr} {self.tf} {self.pw} {self.per})\"\n        )\n</code></pre>"},{"location":"reference/core/#spicelab.core.Ipwl","title":"<code>Ipwl</code>","text":"<p>               Bases: <code>Component</code></p> <p>Fonte de corrente PWL(args_raw).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Ipwl(Component):\n    \"\"\"Fonte de corrente PWL(args_raw).\"\"\"\n\n    def __init__(self, ref: str, args_raw: str) -&gt; None:\n        super().__init__(ref=ref, value=\"\")\n        self.args_raw = args_raw\n        self._ports = (Port(self, \"p\", PortRole.POSITIVE), Port(self, \"n\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        p, n = self.ports\n        return f\"I{self.ref} {net_of(p)} {net_of(n)} PWL({self.args_raw})\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Net","title":"<code>Net</code>  <code>dataclass</code>","text":"<p>Logical node. Name is optional and used for debug; '0' is reserved for GND.</p> Source code in <code>spicelab/core/net.py</code> <pre><code>@dataclass(frozen=True)\nclass Net:\n    \"\"\"Logical node. Name is optional and used for debug; '0' is reserved for GND.\"\"\"\n\n    name: str | None = None\n</code></pre>"},{"location":"reference/core/#spicelab.core.OpAmpIdeal","title":"<code>OpAmpIdeal</code>","text":"<p>               Bases: <code>Component</code></p> <p>Op-amp ideal de 3 pinos (inp, inn, out) modelado por VCVS de alto ganho.</p> <p>Carta: E out 0 inp inn  Source code in <code>spicelab/core/components.py</code> <pre><code>class OpAmpIdeal(Component):\n    \"\"\"Op-amp ideal de 3 pinos (inp, inn, out) modelado por VCVS de alto ganho.\n\n    Carta: E&lt;ref&gt; out 0 inp inn &lt;gain&gt;\n    \"\"\"\n\n    def __init__(self, ref: str, gain: str | float = 1e6) -&gt; None:\n        super().__init__(ref=ref, value=str(gain))\n        self._ports = (\n            Port(self, \"inp\", PortRole.POSITIVE),\n            Port(self, \"inn\", PortRole.NEGATIVE),\n            Port(self, \"out\", PortRole.POSITIVE),\n        )\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        inp, inn, out = self.ports\n        return f\"E{self.ref} {net_of(out)} 0 {net_of(inp)} {net_of(inn)} {self.value}\"\n</code></pre> <p>Include the core public API (Circuit, Component base types, net utilities).</p>"},{"location":"reference/core/#spicelab.core.Resistor","title":"<code>Resistor</code>","text":"<p>               Bases: <code>Component</code></p> <p>Resistor de 2 terminais; portas: a (positivo), b (negativo).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Resistor(Component):\n    \"\"\"Resistor de 2 terminais; portas: a (positivo), b (negativo).\"\"\"\n\n    def __init__(self, ref: str, value: str | float = \"\") -&gt; None:\n        super().__init__(ref=ref, value=value)\n        self._ports = (Port(self, \"a\", PortRole.POSITIVE), Port(self, \"b\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        a, b = self.ports\n        return f\"R{self.ref} {net_of(a)} {net_of(b)} {self.value}\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Vdc","title":"<code>Vdc</code>","text":"<p>               Bases: <code>Component</code></p> <p>Fonte de tens\u00e3o DC; portas: p (positivo), n (negativo).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Vdc(Component):\n    \"\"\"Fonte de tens\u00e3o DC; portas: p (positivo), n (negativo).\"\"\"\n\n    def __init__(self, ref: str, value: str | float = \"\") -&gt; None:\n        super().__init__(ref=ref, value=value)\n        self._ports = (Port(self, \"p\", PortRole.POSITIVE), Port(self, \"n\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        p, n = self.ports\n        # Para DC, escrevemos o valor diretamente\n        return f\"V{self.ref} {net_of(p)} {net_of(n)} {self.value}\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.Vpulse","title":"<code>Vpulse</code>","text":"<p>               Bases: <code>Component</code></p> <p>Fonte de tens\u00e3o PULSE(V1 V2 TD TR TF PW PER).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Vpulse(Component):\n    \"\"\"Fonte de tens\u00e3o PULSE(V1 V2 TD TR TF PW PER).\"\"\"\n\n    def __init__(\n        self,\n        ref: str,\n        v1: str | float,\n        v2: str | float,\n        td: str | float,\n        tr: str | float,\n        tf: str | float,\n        pw: str | float,\n        per: str | float,\n    ) -&gt; None:\n        super().__init__(ref=ref, value=\"\")\n        self.v1, self.v2, self.td, self.tr, self.tf, self.pw, self.per = (\n            v1,\n            v2,\n            td,\n            tr,\n            tf,\n            pw,\n            per,\n        )\n        self._ports = (Port(self, \"p\", PortRole.POSITIVE), Port(self, \"n\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        p, n = self.ports\n        return (\n            f\"V{self.ref} {net_of(p)} {net_of(n)} \"\n            f\"PULSE({self.v1} {self.v2} {self.td} {self.tr} {self.tf} {self.pw} {self.per})\"\n        )\n</code></pre>"},{"location":"reference/core/#spicelab.core.Vpwl","title":"<code>Vpwl</code>","text":"<p>               Bases: <code>Component</code></p> <p>Fonte de tens\u00e3o PWL(args_raw).</p> Source code in <code>spicelab/core/components.py</code> <pre><code>class Vpwl(Component):\n    \"\"\"Fonte de tens\u00e3o PWL(args_raw).\"\"\"\n\n    def __init__(self, ref: str, args_raw: str) -&gt; None:\n        super().__init__(ref=ref, value=\"\")\n        self.args_raw = args_raw\n        self._ports = (Port(self, \"p\", PortRole.POSITIVE), Port(self, \"n\", PortRole.NEGATIVE))\n\n    def spice_card(self, net_of: NetOf) -&gt; str:\n        p, n = self.ports\n        return f\"V{self.ref} {net_of(p)} {net_of(n)} PWL({self.args_raw})\"\n</code></pre>"},{"location":"reference/core/#core-api","title":"Core API","text":"<p>This section will be populated by <code>mkdocstrings</code> from the <code>spicelab.core</code> package.</p> <p>Example:</p> <p>Logical circuit composed of components, nets and raw SPICE directives.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>@dataclass\nclass Circuit:\n    \"\"\"Logical circuit composed of components, nets and raw SPICE directives.\"\"\"\n\n    name: str\n    _net_ids: dict[Net, int] = field(default_factory=dict, init=False)\n    _port_to_net: dict[Port, Net] = field(default_factory=dict, init=False)\n    _components: list[Component] = field(default_factory=list, init=False)\n    _directives: list[str] = field(default_factory=list, init=False)\n    # metadata captured when loading from existing netlists\n    _subckt_defs: dict[str, str] = field(default_factory=dict, init=False)\n    _subckt_instances: list[dict[str, object]] = field(default_factory=list, init=False)\n\n    # ----------------------------------------------------------------------------------\n    # Building blocks\n    # ----------------------------------------------------------------------------------\n    def add(self, *components: Component) -&gt; Circuit:\n        \"\"\"Append one or more components to the circuit.\"\"\"\n\n        self._components.extend(components)\n        return self\n\n    def add_directive(self, line: str) -&gt; Circuit:\n        \"\"\"Append a raw SPICE directive (``.model``, ``.param`` ...).\"\"\"\n\n        self._directives.append(line.rstrip(\"\\n\"))\n        return self\n\n    def add_directive_once(self, line: str) -&gt; Circuit:\n        \"\"\"Add a directive if an identical line (ignoring whitespace) is absent.\"\"\"\n\n        normalized = line.strip()\n        for existing in self._directives:\n            if existing.strip() == normalized:\n                return self\n        return self.add_directive(line)\n\n    def connect(self, a: Port, b: Net | Port) -&gt; Circuit:\n        \"\"\"Connect a port to another port or to a logical net.\"\"\"\n\n        if isinstance(b, Port):\n            net_a = self._port_to_net.get(a)\n            net_b = self._port_to_net.get(b)\n            if net_a and net_b and net_a is not net_b:\n                # merge: remap every port previously associated with net_b to net_a\n                for port, current in list(self._port_to_net.items()):\n                    if current is net_b:\n                        self._port_to_net[port] = net_a\n            else:\n                shared = net_a or net_b or Net()\n                self._port_to_net[a] = shared\n                self._port_to_net[b] = shared\n        else:\n            self._port_to_net[a] = b\n        return self\n\n    # ----------------------------------------------------------------------------------\n    # Net handling\n    # ----------------------------------------------------------------------------------\n    def _assign_node_ids(self) -&gt; None:\n        self._net_ids.clear()\n        self._net_ids[GND] = 0\n\n        next_id = 1\n        seen: set[Net] = {GND}\n\n        def nets_from_components() -&gt; Iterable[Net]:\n            for comp in self._components:\n                for port in comp.ports:\n                    net = self._port_to_net.get(port)\n                    if net is not None:\n                        yield net\n\n        for net in nets_from_components():\n            if net in seen:\n                continue\n            seen.add(net)\n            if getattr(net, \"name\", None) and net.name != \"0\":\n                # preserve named nets but still assign an id for bookkeeping\n                self._net_ids[net] = next_id\n            else:\n                self._net_ids[net] = next_id\n            next_id += 1\n\n    def _net_of(self, port: Port) -&gt; str:\n        net = self._port_to_net.get(port)\n        if net is None:\n            raise ValueError(f\"Unconnected port: {port.owner.ref}.{port.name}\")\n\n        if net is GND or getattr(net, \"name\", None) == \"0\":\n            return \"0\"\n\n        if getattr(net, \"name\", None):\n            return str(net.name)\n\n        node_id = self._net_ids.get(net)\n        if node_id is None:\n            raise RuntimeError(\"Node IDs not assigned\")\n        return str(node_id)\n\n    # ----------------------------------------------------------------------------------\n    # Netlist helpers\n    # ----------------------------------------------------------------------------------\n    def build_netlist(self) -&gt; str:\n        \"\"\"Return a SPICE netlist representation of this circuit.\"\"\"\n\n        self._assign_node_ids()\n\n        lines: list[str] = [f\"* {self.name}\"]\n\n        for comp in self._components:\n            card = comp.spice_card(self._net_of)\n            # components such as AnalogMux may emit multi-line cards\n            for ln in card.splitlines():\n                if ln.strip():\n                    lines.append(ln)\n\n        for directive in self._directives:\n            lines.extend(directive.splitlines())\n\n        if not any(line.strip().lower() == \".end\" for line in lines):\n            lines.append(\".end\")\n\n        return \"\\n\".join(lines) + \"\\n\"\n\n    def save_netlist(self, path: str | Path) -&gt; Path:\n        \"\"\"Persist the netlist to ``path`` and return the resolved ``Path``.\"\"\"\n\n        p = Path(path)\n        p.write_text(self.build_netlist(), encoding=\"utf-8\")\n        return p\n\n    # ----------------------------------------------------------------------------------\n    # Introspection helpers\n    # ----------------------------------------------------------------------------------\n    def _net_label(self, net: Net | None) -&gt; str:\n        if net is None:\n            return \"&lt;unconnected&gt;\"\n        if net is GND or getattr(net, \"name\", None) == \"0\":\n            return \"0\"\n        if getattr(net, \"name\", None):\n            return str(net.name)\n        node_id = self._net_ids.get(net)\n        if node_id is None:\n            self._assign_node_ids()\n            node_id = self._net_ids.get(net)\n        return f\"N{node_id:03d}\" if node_id is not None else \"&lt;unnamed&gt;\"\n\n    def summary(self) -&gt; str:\n        \"\"\"Return a human-readable summary of the circuit and connectivity.\"\"\"\n\n        self._assign_node_ids()\n\n        lines: list[str] = []\n        warnings: list[str] = []\n\n        lines.append(f\"Circuit: {self.name}\")\n        lines.append(f\"Components ({len(self._components)}):\")\n\n        for comp in self._components:\n            port_descriptions: list[str] = []\n            for port in comp.ports:\n                net = self._port_to_net.get(port)\n                label = self._net_label(net)\n                if label == \"&lt;unconnected&gt;\":\n                    warnings.append(f\"Port {comp.ref}.{port.name} is unconnected\")\n                port_descriptions.append(f\"{port.name}-&gt;{label}\")\n            port_info = \", \".join(port_descriptions) if port_descriptions else \"&lt;no ports&gt;\"\n            lines.append(f\"  - {comp.ref} ({type(comp).__name__}): {port_info}\")\n\n        net_names = sorted({self._net_label(net) for net in self._port_to_net.values() if net})\n        if net_names:\n            lines.append(f\"Nets ({len(net_names)}): {', '.join(net_names)}\")\n\n        if warnings:\n            lines.append(\"Warnings:\")\n            for msg in warnings:\n                lines.append(f\"  * {msg}\")\n        else:\n            lines.append(\"Warnings: none\")\n\n        return \"\\n\".join(lines)\n\n    def to_dot(self) -&gt; str:\n        \"\"\"Return a Graphviz DOT representation of the circuit.\"\"\"\n\n        self._assign_node_ids()\n\n        lines: list[str] = [\"graph circuit {\", \"  rankdir=LR;\"]\n\n        comp_ids: dict[Component, str] = {}\n        for idx, comp in enumerate(self._components, start=1):\n            comp_id = f\"comp_{idx}\"\n            comp_ids[comp] = comp_id\n            label = f\"{comp.ref}\\\\n{type(comp).__name__}\"\n            lines.append(f'  \"{comp_id}\" [shape=box,label=\"{label}\"];')\n\n        net_ids: dict[Net | None, str] = {}\n        net_counter = 1\n\n        def _net_node(net: Net | None) -&gt; str:\n            nonlocal net_counter\n            if net in net_ids:\n                return net_ids[net]\n            node_id = f\"net_{net_counter}\"\n            net_counter += 1\n            label = self._net_label(net)\n            shape = \"ellipse\" if label != \"&lt;unconnected&gt;\" else \"point\"\n            net_ids[net] = node_id\n            lines.append(f'  \"{node_id}\" [shape={shape},label=\"{label}\"];')\n            return node_id\n\n        for comp in self._components:\n            comp_id = comp_ids[comp]\n            for port in comp.ports:\n                net = self._port_to_net.get(port)\n                net_id = _net_node(net)\n                lines.append(f'  \"{comp_id}\" -- \"{net_id}\" [label=\"{port.name}\",fontsize=10];')\n\n        lines.append(\"}\")\n        return \"\\n\".join(lines)\n\n    # ----------------------------------------------------------------------------------\n    # Netlist import\n    # ----------------------------------------------------------------------------------\n    @classmethod\n    def from_netlist(cls, path: str | Path) -&gt; Circuit:\n        \"\"\"Load a circuit from a plain SPICE netlist file.\"\"\"\n\n        p = Path(path)\n        text = p.read_text(encoding=\"utf-8\")\n\n        from spicelab.io.spice_parser import parse_lines_to_ast, preprocess_netlist\n\n        lines = preprocess_netlist(text)\n        ast = parse_lines_to_ast(lines)\n\n        name = p.stem\n        if lines and lines[0].lstrip().startswith(\"*\"):\n            maybe_title = lines[0].lstrip()[1:].strip()\n            if maybe_title:\n                name = maybe_title\n\n        circ = cls(name=name)\n\n        for node in ast:\n            kind_obj = node.get(\"type\")\n            kind = str(kind_obj) if isinstance(kind_obj, str) else None\n            raw_obj = node.get(\"raw\")\n            raw = str(raw_obj) if isinstance(raw_obj, str) else \"\"\n\n            if kind == \"subckt\":\n                header = raw.splitlines()[0]\n                parts = header.split()\n                if len(parts) &gt;= 2:\n                    circ._subckt_defs[parts[1]] = raw\n                circ.add_directive(raw)\n                continue\n\n            if kind == \"comment\" or kind == \"directive\":\n                circ.add_directive(raw)\n                continue\n\n            if kind != \"component\":\n                continue\n\n            tokens_obj = node.get(\"tokens\")\n            tokens: list[str] = [str(t) for t in tokens_obj] if isinstance(tokens_obj, list) else []\n            if not tokens:\n                continue\n\n            card = tokens[0]\n            letter = cast(str | None, node.get(\"letter\"))\n            ref = cast(str | None, node.get(\"ref\"))\n\n            try:\n                comp = cls._component_from_tokens(letter, ref, tokens)\n                if comp is None:\n                    circ.add_directive(raw)\n                    continue\n                circ.add(comp)\n                circ._connect_from_tokens(comp, tokens[1:])\n                if letter == \"X\":\n                    circ._subckt_instances.append(\n                        {\"inst\": card, \"subckt\": tokens[-1], \"tokens\": tokens}\n                    )\n            except Exception as exc:  # pragma: no cover - defensive fallback\n                log.warning(\"Failed to parse component '%s': %s\", card, exc)\n                circ.add_directive(raw)\n\n        return circ\n\n    # ----------------------------------------------------------------------------------\n    # Helpers for from_netlist\n    # ----------------------------------------------------------------------------------\n    @staticmethod\n    def _component_from_tokens(\n        letter: str | None, ref: str | None, tokens: list[str]\n    ) -&gt; Component | None:\n        if not letter or not ref:\n            return None\n\n        letter = letter.upper()\n        value = \" \".join(tokens[3:]) if len(tokens) &gt; 3 else \"\"\n\n        if letter == \"R\":\n            return Resistor(ref=ref, value=value)\n        if letter == \"C\":\n            return Capacitor(ref=ref, value=value)\n        if letter == \"L\":\n            return Inductor(ref=ref, value=value)\n        if letter == \"V\":\n            return Vdc(ref=ref, value=value)\n        if letter == \"I\":\n            return Idc(ref=ref, value=value)\n        if letter == \"E\":\n            gain = \" \".join(tokens[5:]) if len(tokens) &gt; 5 else \"\"\n            return VCVS(ref=ref, gain=gain)\n        if letter == \"G\":\n            gm = \" \".join(tokens[5:]) if len(tokens) &gt; 5 else \"\"\n            return VCCS(ref=ref, gm=gm)\n        if letter == \"F\":\n            gain = \" \".join(tokens[4:]) if len(tokens) &gt; 4 else \"\"\n            ctrl = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return CCCS(ref=ref, ctrl_vsrc=ctrl, gain=gain)\n        if letter == \"H\":\n            r = \" \".join(tokens[4:]) if len(tokens) &gt; 4 else \"\"\n            ctrl = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return CCVS(ref=ref, ctrl_vsrc=ctrl, r=r)\n        if letter == \"D\":\n            model = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return Diode(ref=ref, model=model)\n        if letter == \"S\":\n            model = \" \".join(tokens[5:]) if len(tokens) &gt; 5 else \"\"\n            return VSwitch(ref=ref, model=model)\n        if letter == \"W\":\n            model = \" \".join(tokens[4:]) if len(tokens) &gt; 4 else \"\"\n            ctrl = tokens[3] if len(tokens) &gt; 3 else \"\"\n            return ISwitch(ref=ref, ctrl_vsrc=ctrl, model=model)\n\n        # Subcircuits and unsupported devices are preserved as directives\n        return None\n\n    def _connect_from_tokens(self, component: Component, node_tokens: list[str]) -&gt; None:\n        port_iter = iter(component.ports)\n        for node_name in node_tokens:\n            try:\n                port = next(port_iter)\n            except StopIteration:\n                break\n            net = self._get_or_create_net(node_name)\n            self.connect(port, net)\n\n    def _get_or_create_net(self, name: str) -&gt; Net:\n        if name == \"0\":\n            return GND\n        for net in self._port_to_net.values():\n            if getattr(net, \"name\", None) == name:\n                return net\n        new = Net(name)\n        return new\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.add","title":"<code>add(*components)</code>","text":"<p>Append one or more components to the circuit.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def add(self, *components: Component) -&gt; Circuit:\n    \"\"\"Append one or more components to the circuit.\"\"\"\n\n    self._components.extend(components)\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.add_directive","title":"<code>add_directive(line)</code>","text":"<p>Append a raw SPICE directive (<code>.model</code>, <code>.param</code> ...).</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def add_directive(self, line: str) -&gt; Circuit:\n    \"\"\"Append a raw SPICE directive (``.model``, ``.param`` ...).\"\"\"\n\n    self._directives.append(line.rstrip(\"\\n\"))\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.add_directive_once","title":"<code>add_directive_once(line)</code>","text":"<p>Add a directive if an identical line (ignoring whitespace) is absent.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def add_directive_once(self, line: str) -&gt; Circuit:\n    \"\"\"Add a directive if an identical line (ignoring whitespace) is absent.\"\"\"\n\n    normalized = line.strip()\n    for existing in self._directives:\n        if existing.strip() == normalized:\n            return self\n    return self.add_directive(line)\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.build_netlist","title":"<code>build_netlist()</code>","text":"<p>Return a SPICE netlist representation of this circuit.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def build_netlist(self) -&gt; str:\n    \"\"\"Return a SPICE netlist representation of this circuit.\"\"\"\n\n    self._assign_node_ids()\n\n    lines: list[str] = [f\"* {self.name}\"]\n\n    for comp in self._components:\n        card = comp.spice_card(self._net_of)\n        # components such as AnalogMux may emit multi-line cards\n        for ln in card.splitlines():\n            if ln.strip():\n                lines.append(ln)\n\n    for directive in self._directives:\n        lines.extend(directive.splitlines())\n\n    if not any(line.strip().lower() == \".end\" for line in lines):\n        lines.append(\".end\")\n\n    return \"\\n\".join(lines) + \"\\n\"\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.connect","title":"<code>connect(a, b)</code>","text":"<p>Connect a port to another port or to a logical net.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def connect(self, a: Port, b: Net | Port) -&gt; Circuit:\n    \"\"\"Connect a port to another port or to a logical net.\"\"\"\n\n    if isinstance(b, Port):\n        net_a = self._port_to_net.get(a)\n        net_b = self._port_to_net.get(b)\n        if net_a and net_b and net_a is not net_b:\n            # merge: remap every port previously associated with net_b to net_a\n            for port, current in list(self._port_to_net.items()):\n                if current is net_b:\n                    self._port_to_net[port] = net_a\n        else:\n            shared = net_a or net_b or Net()\n            self._port_to_net[a] = shared\n            self._port_to_net[b] = shared\n    else:\n        self._port_to_net[a] = b\n    return self\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.from_netlist","title":"<code>from_netlist(path)</code>  <code>classmethod</code>","text":"<p>Load a circuit from a plain SPICE netlist file.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>@classmethod\ndef from_netlist(cls, path: str | Path) -&gt; Circuit:\n    \"\"\"Load a circuit from a plain SPICE netlist file.\"\"\"\n\n    p = Path(path)\n    text = p.read_text(encoding=\"utf-8\")\n\n    from spicelab.io.spice_parser import parse_lines_to_ast, preprocess_netlist\n\n    lines = preprocess_netlist(text)\n    ast = parse_lines_to_ast(lines)\n\n    name = p.stem\n    if lines and lines[0].lstrip().startswith(\"*\"):\n        maybe_title = lines[0].lstrip()[1:].strip()\n        if maybe_title:\n            name = maybe_title\n\n    circ = cls(name=name)\n\n    for node in ast:\n        kind_obj = node.get(\"type\")\n        kind = str(kind_obj) if isinstance(kind_obj, str) else None\n        raw_obj = node.get(\"raw\")\n        raw = str(raw_obj) if isinstance(raw_obj, str) else \"\"\n\n        if kind == \"subckt\":\n            header = raw.splitlines()[0]\n            parts = header.split()\n            if len(parts) &gt;= 2:\n                circ._subckt_defs[parts[1]] = raw\n            circ.add_directive(raw)\n            continue\n\n        if kind == \"comment\" or kind == \"directive\":\n            circ.add_directive(raw)\n            continue\n\n        if kind != \"component\":\n            continue\n\n        tokens_obj = node.get(\"tokens\")\n        tokens: list[str] = [str(t) for t in tokens_obj] if isinstance(tokens_obj, list) else []\n        if not tokens:\n            continue\n\n        card = tokens[0]\n        letter = cast(str | None, node.get(\"letter\"))\n        ref = cast(str | None, node.get(\"ref\"))\n\n        try:\n            comp = cls._component_from_tokens(letter, ref, tokens)\n            if comp is None:\n                circ.add_directive(raw)\n                continue\n            circ.add(comp)\n            circ._connect_from_tokens(comp, tokens[1:])\n            if letter == \"X\":\n                circ._subckt_instances.append(\n                    {\"inst\": card, \"subckt\": tokens[-1], \"tokens\": tokens}\n                )\n        except Exception as exc:  # pragma: no cover - defensive fallback\n            log.warning(\"Failed to parse component '%s': %s\", card, exc)\n            circ.add_directive(raw)\n\n    return circ\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.save_netlist","title":"<code>save_netlist(path)</code>","text":"<p>Persist the netlist to <code>path</code> and return the resolved <code>Path</code>.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def save_netlist(self, path: str | Path) -&gt; Path:\n    \"\"\"Persist the netlist to ``path`` and return the resolved ``Path``.\"\"\"\n\n    p = Path(path)\n    p.write_text(self.build_netlist(), encoding=\"utf-8\")\n    return p\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.summary","title":"<code>summary()</code>","text":"<p>Return a human-readable summary of the circuit and connectivity.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def summary(self) -&gt; str:\n    \"\"\"Return a human-readable summary of the circuit and connectivity.\"\"\"\n\n    self._assign_node_ids()\n\n    lines: list[str] = []\n    warnings: list[str] = []\n\n    lines.append(f\"Circuit: {self.name}\")\n    lines.append(f\"Components ({len(self._components)}):\")\n\n    for comp in self._components:\n        port_descriptions: list[str] = []\n        for port in comp.ports:\n            net = self._port_to_net.get(port)\n            label = self._net_label(net)\n            if label == \"&lt;unconnected&gt;\":\n                warnings.append(f\"Port {comp.ref}.{port.name} is unconnected\")\n            port_descriptions.append(f\"{port.name}-&gt;{label}\")\n        port_info = \", \".join(port_descriptions) if port_descriptions else \"&lt;no ports&gt;\"\n        lines.append(f\"  - {comp.ref} ({type(comp).__name__}): {port_info}\")\n\n    net_names = sorted({self._net_label(net) for net in self._port_to_net.values() if net})\n    if net_names:\n        lines.append(f\"Nets ({len(net_names)}): {', '.join(net_names)}\")\n\n    if warnings:\n        lines.append(\"Warnings:\")\n        for msg in warnings:\n            lines.append(f\"  * {msg}\")\n    else:\n        lines.append(\"Warnings: none\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/#spicelab.core.circuit.Circuit.to_dot","title":"<code>to_dot()</code>","text":"<p>Return a Graphviz DOT representation of the circuit.</p> Source code in <code>spicelab/core/circuit.py</code> <pre><code>def to_dot(self) -&gt; str:\n    \"\"\"Return a Graphviz DOT representation of the circuit.\"\"\"\n\n    self._assign_node_ids()\n\n    lines: list[str] = [\"graph circuit {\", \"  rankdir=LR;\"]\n\n    comp_ids: dict[Component, str] = {}\n    for idx, comp in enumerate(self._components, start=1):\n        comp_id = f\"comp_{idx}\"\n        comp_ids[comp] = comp_id\n        label = f\"{comp.ref}\\\\n{type(comp).__name__}\"\n        lines.append(f'  \"{comp_id}\" [shape=box,label=\"{label}\"];')\n\n    net_ids: dict[Net | None, str] = {}\n    net_counter = 1\n\n    def _net_node(net: Net | None) -&gt; str:\n        nonlocal net_counter\n        if net in net_ids:\n            return net_ids[net]\n        node_id = f\"net_{net_counter}\"\n        net_counter += 1\n        label = self._net_label(net)\n        shape = \"ellipse\" if label != \"&lt;unconnected&gt;\" else \"point\"\n        net_ids[net] = node_id\n        lines.append(f'  \"{node_id}\" [shape={shape},label=\"{label}\"];')\n        return node_id\n\n    for comp in self._components:\n        comp_id = comp_ids[comp]\n        for port in comp.ports:\n            net = self._port_to_net.get(port)\n            net_id = _net_node(net)\n            lines.append(f'  \"{comp_id}\" -- \"{net_id}\" [label=\"{port.name}\",fontsize=10];')\n\n    lines.append(\"}\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/io/","title":"IO API","text":"<p>Placeholder for IO-related API docs.</p>"},{"location":"reference/io/#spicelab.io.raw_reader.Trace","title":"<code>Trace</code>  <code>dataclass</code>","text":"<p>Um tra\u00e7o: nome, unidade (quando existir) e vetor de valores (np.ndarray).</p> Source code in <code>spicelab/io/raw_reader.py</code> <pre><code>@dataclass(frozen=True)\nclass Trace:\n    \"\"\"Um tra\u00e7o: nome, unidade (quando existir) e vetor de valores (np.ndarray).\"\"\"\n\n    name: str\n    unit: str | None\n    values: NDArray[Any]\n    _complex: NDArray[Any] | None = None  # apenas AC: vetor complex\n\n    def magnitude(self) -&gt; NDArray[Any]:\n        if self._complex is not None:\n            return cast(NDArray[Any], np.abs(self._complex))\n        return cast(NDArray[Any], np.abs(self.values))\n\n    def real(self) -&gt; NDArray[Any]:\n        if self._complex is not None:\n            return self._complex.real\n        return self.values\n\n    def imag(self) -&gt; NDArray[Any]:\n        if self._complex is not None:\n            return self._complex.imag\n        return np.zeros_like(self.values, dtype=float)\n\n    def phase_deg(self) -&gt; NDArray[Any]:\n        if self._complex is not None:\n            return np.angle(self._complex, deg=True)\n        return np.zeros_like(self.values, dtype=float)\n</code></pre>"},{"location":"reference/io/#spicelab.io.raw_reader.TraceSet","title":"<code>TraceSet</code>","text":"<p>Conjunto de tra\u00e7os indexado por nome. O primeiro tra\u00e7o \u00e9 o eixo X (time/freq).</p> Acesso <p>ts[\"V(out)\"] -&gt; Trace ts.x -&gt; Trace (primeira coluna) ts.names -&gt; lista de nomes ts.to_dataframe() -&gt; pandas.DataFrame (se pandas instalado)</p> Source code in <code>spicelab/io/raw_reader.py</code> <pre><code>class TraceSet:\n    \"\"\"\n    Conjunto de tra\u00e7os indexado por nome. O primeiro tra\u00e7o \u00e9 o eixo X (time/freq).\n\n    Acesso:\n        ts[\"V(out)\"] -&gt; Trace\n        ts.x -&gt; Trace (primeira coluna)\n        ts.names -&gt; lista de nomes\n        ts.to_dataframe() -&gt; pandas.DataFrame (se pandas instalado)\n    \"\"\"\n\n    def __init__(self, traces: list[Trace]) -&gt; None:\n        if not traces:\n            raise ValueError(\"TraceSet requires at least one trace\")\n        self._traces = traces\n        self._by_name: dict[str, Trace] = {t.name: t for t in traces}\n\n        # valida tamanhos\n        n = len(self._traces[0].values)\n        for t in self._traces[1:]:\n            if len(t.values) != n:\n                raise ValueError(\"All traces must have same length\")\n\n    @property\n    def x(self) -&gt; Trace:\n        return self._traces[0]\n\n    @property\n    def names(self) -&gt; list[str]:\n        return [t.name for t in self._traces]\n\n    def __getitem__(self, key: str) -&gt; Trace:\n        try:\n            return self._by_name[key]\n        except KeyError as e:\n            raise KeyError(f\"Trace '{key}' not found. Available: {self.names}\") from e\n\n    def to_dataframe(self) -&gt; Any:\n        # Evita depender de stubs do pandas: import din\u00e2mico via importlib, tipado como Any\n        try:\n            pd: Any = importlib.import_module(\"pandas\")\n        except Exception as exc:  # pragma: no cover\n            raise RuntimeError(\"pandas is required for to_dataframe()\") from exc\n        data = {t.name: t.values for t in self._traces}\n        return pd.DataFrame(data)\n</code></pre>"},{"location":"reference/io/#spicelab.io.raw_reader.parse_ngspice_ascii_raw","title":"<code>parse_ngspice_ascii_raw(path)</code>","text":"<p>Parser robusto para NGSpice ASCII RAW.</p> <p>Retorna TraceSet onde a primeira coluna \u00e9 o eixo X (tipicamente 'time' ou 'frequency').</p> Source code in <code>spicelab/io/raw_reader.py</code> <pre><code>def parse_ngspice_ascii_raw(path: str) -&gt; TraceSet:\n    \"\"\"\n    Parser robusto para NGSpice ASCII RAW.\n\n    Retorna TraceSet onde a primeira coluna \u00e9 o eixo X (tipicamente 'time' ou 'frequency').\n    \"\"\"\n    with open(path, encoding=\"utf-8\", errors=\"ignore\") as f:\n        lines = f.read().splitlines()\n\n    meta, i0 = _parse_header(lines)\n    nvars = int(meta[\"nvars\"])\n    npoints = int(meta[\"npoints\"])\n    vars_meta, i1 = _parse_variables(lines, i0, nvars)\n    data, complex_cols = _parse_values(lines, i1, nvars, npoints)\n\n    traces: list[Trace] = []\n    for j, (name, unit) in enumerate(vars_meta):\n        traces.append(\n            Trace(\n                name=name,\n                unit=unit,\n                values=data[:, j].copy(),\n                _complex=complex_cols[j],\n            )\n        )\n    return TraceSet(traces)\n</code></pre>"},{"location":"reference/io/#spicelab.io.raw_reader.parse_ngspice_ascii_raw_multi","title":"<code>parse_ngspice_ascii_raw_multi(path)</code>","text":"<p>L\u00ea um arquivo ASCII com m\u00faltiplos plots (p.ex. .step nativo) e retorna uma lista de TraceSet (um por bloco).</p> Source code in <code>spicelab/io/raw_reader.py</code> <pre><code>def parse_ngspice_ascii_raw_multi(path: str) -&gt; list[TraceSet]:\n    \"\"\"\n    L\u00ea um arquivo ASCII com m\u00faltiplos plots (p.ex. .step nativo) e retorna\n    uma lista de TraceSet (um por bloco).\n    \"\"\"\n    with open(path, encoding=\"utf-8\", errors=\"ignore\") as f:\n        lines = f.read().splitlines()\n\n    i = 0\n    out: list[TraceSet] = []\n    while i &lt; len(lines):\n        # procurar in\u00edcio de um bloco (Title:/Plotname:/Variables:)\n        # Reutiliza as fun\u00e7\u00f5es privadas para cada bloco\n        # pular linhas vazias\n        while i &lt; len(lines) and not lines[i].strip():\n            i += 1\n        if i &gt;= len(lines):\n            break\n        # precisa ver se h\u00e1 um cabe\u00e7alho v\u00e1lido\n        try:\n            meta, i0 = _parse_header(lines[i:])\n            nvars = int(meta[\"nvars\"])\n            npoints = int(meta[\"npoints\"])\n            vars_meta, i1 = _parse_variables(lines[i:], i0, nvars)\n            data, complex_cols = _parse_values(lines[i:], i1, nvars, npoints)\n        except Exception:\n            # se n\u00e3o conseguiu, avan\u00e7a uma linha e tenta de novo\n            i += 1\n            continue\n\n        traces: list[Trace] = []\n        for j, (name, unit) in enumerate(vars_meta):\n            traces.append(\n                Trace(name=name, unit=unit, values=data[:, j].copy(), _complex=complex_cols[j])\n            )\n        out.append(TraceSet(traces))\n        # avan\u00e7ar: i += i1 + npoints ... mas j\u00e1 usamos slices; ent\u00e3o mova i para frente\n        # tenta achar pr\u00f3ximo 'Title:' ap\u00f3s o bloco atual\n        # heur\u00edstica simples: move i at\u00e9 encontrar pr\u00f3xima 'Title:' ou EOF\n        k = i + i1 + npoints + 4  # + margem\n        i = max(i + 1, k)\n    return out\n</code></pre>"},{"location":"reference/io/#spicelab.io.raw_reader.parse_ngspice_raw","title":"<code>parse_ngspice_raw(path)</code>","text":"<p>Dispatcher: se for ASCII, usa parse_ngspice_ascii_raw; se for 'Binary', tenta fallback convertendo para ASCII n\u00e3o invasivo (a depender da gera\u00e7\u00e3o do arquivo). Por ora, detecta 'Binary' e dispara erro com mensagem clara.</p> Source code in <code>spicelab/io/raw_reader.py</code> <pre><code>def parse_ngspice_raw(path: str) -&gt; TraceSet:\n    \"\"\"\n    Dispatcher: se for ASCII, usa parse_ngspice_ascii_raw; se for 'Binary', tenta\n    fallback convertendo para ASCII n\u00e3o invasivo (a depender da gera\u00e7\u00e3o do arquivo).\n    Por ora, detecta 'Binary' e dispara erro com mensagem clara.\n    \"\"\"\n    with open(path, \"rb\") as f:\n        head = f.read(256)\n    if b\"Binary:\" in head or b\"binary\" in head:\n        # Implementa\u00e7\u00e3o bin\u00e1ria completa \u00e9 extensa; orientar uso de ASCII no runner.\n        raise NotImplementedError(\n            \"Binary RAW not supported yet. Configure NGSpice to write ASCII RAW \"\n            \"(set filetype=ascii).\"\n        )\n    # ASCII\n    return parse_ngspice_ascii_raw(path)\n</code></pre>"}]}